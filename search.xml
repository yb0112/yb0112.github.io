<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>响应式原理模拟</title>
    <url>/posts/e3abf81e.html</url>
    <content><![CDATA[<p><img src="/posts/e3abf81e/liuchen.png" alt="mvvm响应式原理"> </p>
<span id="more"></span>
<p>Vue.js是当前比较火的JavaScript MVVM（Model View ViewModel），数据，视图，视图模型）库，它跟以往的不同之处在于，之前更多的是手动操作Dom，现在是以数据为驱动，本篇文章通过对<code>数据驱动</code>、<code>数据响应式的核心原理</code>、<code>发布订阅模式</code>、<code>观察者模式</code>这几个知识点的学习，然后模拟vue响应式原理，实现一个简单小版本的Vue。</p>
<h3 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h3><p>说到数据驱动，首先对<code>数据响应式</code>、<code>双向绑定</code>、<code>数据驱动</code> 这三个模块进行一个简单介绍</p>
<ul>
<li>数据响应式<br>  数据响应式中的数据指的是数据模型，数据模型仅仅是普通的JavaScript对象，数据响应式的核心指的是当我们修改数据时，视图会进行更新，避免了繁琐的DOM操作，提高开发效率。</li>
<li>双向绑定<br>  数据改变，视图改变；视图改变，数据也随之改变；我们可以使用v-model在表单元素上创建双向数据绑定。</li>
<li>数据驱动<br>  这个是Vue最独特的特性之一，让我们在开发过程中仅需要关注数据本身，不需要关心数据是如何渲染到视图的。<h3 id="数据响应式的核心原理"><a href="#数据响应式的核心原理" class="headerlink" title="数据响应式的核心原理"></a>数据响应式的核心原理</h3><h4 id="Vue2-x"><a href="#Vue2-x" class="headerlink" title="Vue2.x"></a>Vue2.x</h4>Vue2.x的核心是通过<code>Object.defineProperty</code>把数据转成<code>getter/setter</code>让Vue能够追踪依赖，在数据被访问和修改时，可以进行进行数据劫持通知变更。</li>
<li><a href="https://cn.vuejs.org/v2/guide/reactivity.html">Vue2.x响应式原理</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN-Object.defineProperty</a></li>
<li><code>Object.defineProperty</code> 是 ES5 中一个无法 <code>shim（在一个旧的环境中模拟出一个新 API ，而且仅靠旧环境中已有的手段实现，以便所有的浏览器具有相同的行为）</code>的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</li>
<li>Vue 官方对于 ie 浏览器版本兼容情况的描述是 ie9+，即是 ie9 及更高的版本。经过测试，Vue 的核心框架 vuejs本身，以及生态的官方核心插件（VueRouter、Vuex等）均可以在 ie9 上正常使用。解决方案是使用 babel-polyfill，它可以将 es6 的代码翻译成低版本浏览器可以识别的 es5 代码.</li>
</ul>
<p><code>Object.defineProperty</code>基本使用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>defineProperty<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        hello</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 模拟 Vue中的data选项</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> data = &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">msg</span>: <span class="string">&#x27;Hello&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 模拟vue实例</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> vm = &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 数据劫持：当访问者或者访问vm中成员的时候，做一些干预操作</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 三个参数：1.对象   2.对象增加的属性  3.属性描述</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(vm, <span class="string">&#x27;msg&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 可枚举（可遍历）</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">enumerable</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 可配置（可以使用delete删除，或可以通过 defineProperty 重新定义）</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">configurable</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 当获取值的时候执行</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">get</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get:&#x27;</span>,data.<span class="property">msg</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 当设置值的时候执行</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">set</span>(<span class="params">newValue</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set:&#x27;</span>,newValue)</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span>(newValue == data.<span class="property">msg</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">return</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                data.<span class="property">msg</span> = newValue</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 数据更改，更新DOM的值</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">textContent</span> = data.<span class="property">msg</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在控制台通过<code>vm.msg</code>获取值的时候，触发了<code>get</code>的方法，通过<code>vm.msg=&#39;xxx&#39;</code>,触发了<code>set</code>的方法，效果如下：<br><img src="/posts/e3abf81e/1.png" alt="控制台展示"><br>以上代码模拟的是对一个对象中一个属性<code>msg</code>的转换<code>getter/setter</code>，那么如果一个对象中多个属性需要转换<code>getter/setter</code>如何处理呢？<br>思路如下：通过<code> Object.keys()</code>遍历，然后再转换成vm的<code>setter/getter</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>defineProperty<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        hello</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 模拟 Vue中的data选项</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> data = &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">msg</span>: <span class="string">&#x27;Hello&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">count</span>: <span class="number">100</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 模拟vue实例</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> vm = &#123;&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">proxyData</span>(data)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">proxyData</span>(<span class="params">data</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 遍历data对象中的所有属性</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 把data 中的属性，转换成vm的setter/getter</span></span></span><br><span class="line"><span class="language-javascript">                <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(vm, key, &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">configurable</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">get</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get:&#x27;</span>, key, data[key])</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">return</span> data[key]</span></span><br><span class="line"><span class="language-javascript">                    &#125;,</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">set</span>(<span class="params">newValue</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set:&#x27;</span>, key, newValue)</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">if</span>(newValue === data[key])&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="keyword">return</span></span></span><br><span class="line"><span class="language-javascript">                        &#125;</span></span><br><span class="line"><span class="language-javascript">                        data[key] = newValue</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">// 数据更改，更新DOM的值</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">textContent</span> = data[key]</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;)</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Vue3-x"><a href="#Vue3-x" class="headerlink" title="Vue3.x"></a>Vue3.x</h4><p>Vue3.x核心的是通过<code>Proxy</code>把数据转成<code>getter/setter</code>让Vue能够追踪依赖。</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">MDN-Proxy</a></li>
<li>直接监听对象，并非属性</li>
<li>ES6 中新增，IE不支持，性能由浏览器优化（比Object.defineProperty好）</li>
</ul>
<p>使用如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        hello</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 模拟Vue 中 data选项</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> data = &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">count</span>: <span class="number">10</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 模拟Vue实例</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;  <span class="comment">// 第一个参数：代理对象， 第二参数：执行代理行为的函数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 当访问vm 的成员会执行 </span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 两个参数，1: 代理的目标对象，2:要访问的哪个属性</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">get</span>(<span class="params">target, key</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set, key:&#x27;</span>, key, target[key])</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> target[key]</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 当设置vm 的成员会执行</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 三个参数： 1:代理的目标对象，2:设置的哪个属性， 3:设置的新的值</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">set</span>(<span class="params">target,key,newValue</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set,key:&#x27;</span>, key, newValue)</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span>(target[key] === newValue)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">return</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                target[key] = newValue</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#app&quot;</span>).<span class="property">textContent</span> = newValue</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="发布订阅模式-amp-观察者模式"><a href="#发布订阅模式-amp-观察者模式" class="headerlink" title="发布订阅模式 &amp; 观察者模式"></a>发布订阅模式 &amp; 观察者模式</h3><h4 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h4><p>通俗理解，假设存在一个<code>“信号中心”</code>，某个任务执行完毕，就向信号中心<code>“发布”</code>一个信号，其他任务可以向信号中心<code>“订阅”</code>这个信号，从而知道什么时候自己可以开始执行，这就叫<code>发布/订阅模式</code>。</p>
<ul>
<li>订阅者</li>
<li>发布者</li>
<li>信号中心</li>
</ul>
<p>在Vue中的事件机制和Node中的事件就是给予发布订阅模式的，下面兄弟组件通信过程为例：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// eventBus.js</span></span><br><span class="line">    <span class="comment">// 事件中心</span></span><br><span class="line">    <span class="keyword">let</span> eventHub = <span class="keyword">new</span> <span class="constructor">Vue()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组件 ComponentA.vue</span></span><br><span class="line">    <span class="comment">// 发布者</span></span><br><span class="line">    addTodo: <span class="keyword">function</span><span class="literal">()</span>&#123;</span><br><span class="line">        <span class="comment">// 发布消息（事件）</span></span><br><span class="line">        eventHub.<span class="constructor">$emit(&#x27;<span class="params">add</span>-<span class="params">todo</span>&#x27;, &#123; <span class="params">text</span>: <span class="params">this</span>.<span class="params">newTodoText</span> &#125;)</span></span><br><span class="line">        this.newTodoText = &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组件 ComponentB.vue</span></span><br><span class="line">    <span class="comment">//  订阅号</span></span><br><span class="line">    created: <span class="keyword">function</span><span class="literal">()</span>&#123;</span><br><span class="line">        <span class="comment">// 订阅消息（事件）</span></span><br><span class="line">        eventHub.<span class="constructor">$on(&#x27;<span class="params">add</span>-<span class="params">todo</span>&#x27;,<span class="params">this</span>.<span class="params">addTodo</span> )</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="Vue自定义事件的实现"><a href="#Vue自定义事件的实现" class="headerlink" title="Vue自定义事件的实现"></a>Vue自定义事件的实现</h5><p>页面中事件使用写法：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="regexp">//</span> vue 自定义事件</span><br><span class="line">    let vm =  new Vue()</span><br><span class="line">    <span class="regexp">//</span> vm内部的变量是一个对象的形式，对象的属性是事件的名称，对象的值是事件处理函数</span><br><span class="line">    <span class="regexp">//</span> vm内部：&#123;<span class="string">&#x27;click&#x27;</span>:[fn1,fn2], <span class="string">&#x27;change&#x27;</span>:[<span class="string">&#x27;fn3&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span> 注册事件（订阅消息）</span><br><span class="line">    vm.<span class="variable">$on</span>(<span class="string">&#x27;dataChange&#x27;</span>, ()=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">&#x27;dataChange&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    vm.<span class="variable">$on</span>(<span class="string">&#x27;dataChange&#x27;</span>, ()=&gt;&#123;</span><br><span class="line">        console.log(<span class="string">&#x27;dataChange1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span> 触发事件（发布消息）</span><br><span class="line">    vm.<span class="variable">$emit</span>(<span class="string">&#x27;dataChange&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="regexp">//</span> 当通过vm.<span class="variable">$emit</span>触发事件的时候，就会去内部去找到对应的属性，然后去执行对应属性后面的函数</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>实现方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 事件触发器</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">class</span> <span class="title class_">EventEmitter</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// &#123; &#x27;click&#x27;:[ fn1, fn2 ], &#x27;change&#x27;:[ fn ] &#125;</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">subs</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 注册事件  eventType:事件名称  handler: 事件函数</span></span></span><br><span class="line"><span class="language-javascript">        $on(eventType, handler) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 判断上面的 &#123; &#x27;click&#x27;:[ fn1, fn2 ], &#x27;change&#x27;:[ fn ] &#125; 对象刚开始的时候有没有值，</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 有值就直接设置进去，</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 没有值就设置成空数组</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">subs</span>[eventType] = <span class="variable language_">this</span>.<span class="property">subs</span>[eventType] || []</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">subs</span>[eventType].<span class="title function_">push</span>(handler)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 触发事件</span></span></span><br><span class="line"><span class="language-javascript">        $emit(eventType) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">subs</span>[eventType])&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">subs</span>[eventType].<span class="title function_">forEach</span>(<span class="function"><span class="params">handler</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">handler</span>()</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 测试</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> em = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>()</span></span><br><span class="line"><span class="language-javascript">    em.$on(<span class="string">&#x27;click&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;click1&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    em.$on(<span class="string">&#x27;click&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;click2&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    em.$emit(<span class="string">&#x27;click&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打开浏览器在控制台中查看，打印出了<code>click1</code>、<code>click2</code></p>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><ul>
<li>观察者模式（订阅者）–Watcher<ul>
<li>update(): 当事件发生时，具体要做的事情</li>
</ul>
</li>
<li>目标（发布者）–Dep<ul>
<li>subs数组：存储所有的观察者</li>
<li>addsub(): 添加观察者</li>
<li>notify(): 当事件发生，调用所有观察者的update方法</li>
</ul>
</li>
<li>没有事件中心</li>
</ul>
<p>简单实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 发布者--目标</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">constructor</span> ()&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 记录所有的订阅着</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">subs</span> = []</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 把订阅着添加到subs数组里</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">addSub</span>(<span class="params">sub</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(sub &amp;&amp; sub.<span class="property">update</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 当事件发生的时候通知所有的订阅者，调用所有的订阅者update方法</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">notify</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">sub</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                sub.<span class="title function_">update</span>()</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 订阅者--观察者</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">class</span> <span class="title class_">Watcher</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">update</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            consolel.<span class="title function_">log</span>(<span class="string">&#x27;update&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 测试</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> watcher = <span class="keyword">new</span> <span class="title class_">Watcher</span>()</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 将订阅者添加到发布者中，让发布者记录下来所有的观察者</span></span></span><br><span class="line"><span class="language-javascript">    dep.<span class="title function_">addSub</span>(watcher)</span></span><br><span class="line"><span class="language-javascript">    dep.<span class="title function_">notify</span>()</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li><code>观察者模式</code>是由具体目标调度，比如当前事件触发，Dep就会去调用观察者的方法，所以观察者模式的订阅者与发布者之间存在依赖的</li>
<li><code>发布/订阅模式</code>由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在<br><img src="/posts/e3abf81e/2.png" alt="image"></li>
</ul>
<h3 id="模拟Vue响应式原理"><a href="#模拟Vue响应式原理" class="headerlink" title="模拟Vue响应式原理"></a>模拟Vue响应式原理</h3><p>前面的 <code>数据响应式原理</code>、<code>发布/订阅模式</code>、<code>观察者模式</code>都了解之后，将前面的这些方法结合起来，然后模拟一个简单的Vue，在准备模拟开发一个Vue前，首页要对vue的整体结构有个认识，结构如下：<br><img src="/posts/e3abf81e/3.png" alt="image"><br>主要实现 <code>Vue</code>、<code>Observer</code>、<code>Dep</code>、<code>Watcher</code>、<code>Compiler</code> 五种，接着具体分析</p>
<h4 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h4><ul>
<li>负责接收初始化的参数（选项），把data中的成员注入到Vue实例</li>
<li>负责把data中的属性注入到Vue实例，转换成getter/setter</li>
<li>负责调用observer监听data中所有属性变化</li>
<li>负责调用compiler解析指令/差值表达式</li>
</ul>
<p>创建一个<code>minVue/index.html</code>文件</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>mini Vue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>差值表达式<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">msg</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">count</span> &#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>v-text<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>v-model<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;count&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">data</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="attr">count</span>: <span class="number">1000</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>创建一个<code>minVue/js/vue.js</code>文件</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">        <span class="comment">// 1.通过属性保存选项的数据</span></span><br><span class="line">        <span class="keyword">this</span>.$options = options || &#123;&#125;</span><br><span class="line">        <span class="keyword">this</span>.$<span class="keyword">data</span> = options.<span class="keyword">data</span> || &#123;&#125;</span><br><span class="line">        <span class="keyword">this</span>.$el = typeof options.el === <span class="string">&#x27;string&#x27;</span>?document.querySelector(options.el):options.el </span><br><span class="line">        <span class="comment">// 2.把data中的成员转换成getter/setter，注入到vue实例中</span></span><br><span class="line">        <span class="keyword">this</span>._proxyData(<span class="keyword">this</span>.$<span class="keyword">data</span>)</span><br><span class="line">        <span class="comment">// 3.调用Observer对象，监听数据变化</span></span><br><span class="line">        <span class="comment">// 4.调用compiler对象，解析指令和差值表达式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 代理数据 </span></span><br><span class="line">    _proxyData(<span class="keyword">data</span>)&#123;</span><br><span class="line">        <span class="comment">// 遍历data中的所有属性</span></span><br><span class="line">        Object.keys(<span class="keyword">data</span>).forEach(key =&gt; &#123;</span><br><span class="line">            <span class="comment">// 注意：这里的this是上面constructor里面调用函数时候的this，也就是vue实例</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 把data的属性注入到vue实例中</span></span><br><span class="line">            Object.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">                enumerable: <span class="literal">true</span>,</span><br><span class="line">                configurable: <span class="literal">true</span>,</span><br><span class="line">                <span class="keyword">get</span>()&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">data</span>[key]</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">set</span>(newValue)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(newValue === <span class="keyword">data</span>[key])&#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">data</span>[key] = newValue</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><ul>
<li>负责把data选项中的属性转换成响应式数据进行监听</li>
<li>如果data中的某个属性是对象，把该属性转换成响应式数据</li>
<li>如有变化可拿到最新值并通知Dep</li>
</ul>
<p>创建<code>minVue/js/observer.js</code>文件</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="keyword">data</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.walk(<span class="keyword">data</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历对象所有属性</span></span><br><span class="line">    walk(<span class="keyword">data</span>)&#123;</span><br><span class="line">        <span class="comment">// 1.判断data是否是对象</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">data</span> || typeof <span class="keyword">data</span> !== <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.遍历data对象的所有属性</span></span><br><span class="line">        Object.keys(<span class="keyword">data</span>).forEach(key=&gt;&#123;</span><br><span class="line">            <span class="keyword">this</span>.defineReactive(<span class="keyword">data</span>, key, <span class="keyword">data</span>[key])</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Object.defineProperty 把属性转成getter 和setter</span></span><br><span class="line">    <span class="comment">// 三个参数： 1.对象  2.key属性  3.属性对应的值</span></span><br><span class="line">    defineReactive(obj, key, <span class="keyword">val</span>)&#123;</span><br><span class="line">        let that = <span class="keyword">this</span></span><br><span class="line">        <span class="comment">// 如果val是对象，把val内部的属性转换成响应式</span></span><br><span class="line">        <span class="keyword">this</span>.walk(<span class="keyword">val</span>)</span><br><span class="line"></span><br><span class="line">        Object.defineProperty(obj, key, &#123;</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            <span class="keyword">get</span>()&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">val</span>   <span class="comment">// 不能传obj[key],不然会出现死递归，通过传第三个参数val闭包来解决</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>(newValue)&#123;</span><br><span class="line">                <span class="keyword">if</span>(newValue === <span class="keyword">val</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">val</span> = newValue</span><br><span class="line">                <span class="comment">// 如果新赋值的属性是对象进行响应式</span></span><br><span class="line">                that.walk(newValue)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 发送通知</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>vue.js</code>文件中调用<code>Observer</code>对象，监听数据变化</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">        <span class="comment">// 1.通过属性保存选项的数据</span></span><br><span class="line">        <span class="keyword">this</span>.$options = options || &#123;&#125;</span><br><span class="line">        <span class="keyword">this</span>.$<span class="keyword">data</span> = options.<span class="keyword">data</span> || &#123;&#125;</span><br><span class="line">        <span class="keyword">this</span>.$el = typeof options.el === <span class="string">&#x27;string&#x27;</span>?document.querySelector(options.el):options.el </span><br><span class="line">        <span class="comment">// 2.把data中的成员转换成getter/setter，注入到vue实例中</span></span><br><span class="line">        <span class="keyword">this</span>._proxyData(<span class="keyword">this</span>.$<span class="keyword">data</span>)</span><br><span class="line">        <span class="comment">// 3.调用Observer对象，监听数据变化</span></span><br><span class="line">        new Observer(<span class="keyword">this</span>.$<span class="keyword">data</span>)</span><br><span class="line">        <span class="comment">// 4.调用compiler对象，解析指令和差值表达式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 代理数据 </span></span><br><span class="line">    _proxyData(<span class="keyword">data</span>)&#123;</span><br><span class="line">        <span class="comment">// 遍历data中的所有属性</span></span><br><span class="line">        Object.keys(<span class="keyword">data</span>).forEach(key =&gt; &#123;</span><br><span class="line">            <span class="comment">// 注意：这里的this是上面constructor里面调用函数时候的this，也就是vue实例</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 把data的属性注入到vue实例中</span></span><br><span class="line">            Object.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">                enumerable: <span class="literal">true</span>,</span><br><span class="line">                configurable: <span class="literal">true</span>,</span><br><span class="line">                <span class="keyword">get</span>()&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">data</span>[key]</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">set</span>(newValue)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(newValue === <span class="keyword">data</span>[key])&#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">data</span>[key] = newValue</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h4><ul>
<li>负责编译模版，解析指令/差值表达式</li>
<li>负责页面的首次渲染</li>
<li>当数据变化后重新渲染试图</li>
</ul>
<p>创建一个<code>minVue/js/compiler.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Compiler</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">vm</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">el</span> = vm.<span class="property">$el</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">compile</span>(<span class="variable language_">this</span>.<span class="property">el</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 编译模版，处理文本节点和元素节点</span></span><br><span class="line">    <span class="title function_">compile</span>(<span class="params">el</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> childNodes = el.<span class="property">childNodes</span></span><br><span class="line">        <span class="title class_">Array</span>.<span class="title function_">from</span>(childNodes).<span class="title function_">forEach</span>(<span class="function"><span class="params">node</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 处理文本节点</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isTextNode</span>(node))&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">compileText</span>(node)</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isElementNode</span>(node))&#123;</span><br><span class="line">                <span class="comment">// 处理元素节点</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">compileElement</span>(node)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断node节点，是否是子节点，如果有子节点，要递归调用compile</span></span><br><span class="line">            <span class="keyword">if</span>(node.<span class="property">childNodes</span> &amp;&amp; node.<span class="property">childNodes</span>.<span class="property">length</span>)&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">compile</span>(node)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 编译元素节点，处理指令</span></span><br><span class="line">    <span class="title function_">compileElement</span>(<span class="params">node</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">attributes</span>)</span><br><span class="line">        <span class="comment">// 遍历所有的属性节点</span></span><br><span class="line">        <span class="title class_">Array</span>.<span class="title function_">from</span>(node.<span class="property">attributes</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">attr</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 判断是否是指令</span></span><br><span class="line">            <span class="keyword">let</span> attrName = attr.<span class="property">name</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isDirective</span>(attrName))&#123;  <span class="comment">// 判断属性是否是指令（ 以 v- 开头 ）</span></span><br><span class="line">                <span class="comment">// v-text --&gt;  text</span></span><br><span class="line">                attrName = attrName.<span class="title function_">substr</span>(<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">let</span> key = attr.<span class="property">value</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">update</span>(node, key, attrName)  <span class="comment">// 判断什么样的指令，对应的处理方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">update</span>(<span class="params">node, key, attrName</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> updateFn = <span class="variable language_">this</span>[attrName + <span class="string">&#x27;Updater&#x27;</span>]  <span class="comment">// 用于判断使用哪一个处理指令的函数</span></span><br><span class="line">        updateFn &amp;&amp; <span class="title function_">updateFn</span>(node, <span class="variable language_">this</span>.<span class="property">vm</span>[key])   <span class="comment">// 对应的处理方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 v-text 指令</span></span><br><span class="line">    <span class="title function_">textUpdater</span>(<span class="params">node, value</span>)&#123;</span><br><span class="line">        node.<span class="property">textContent</span> = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理v-model指令</span></span><br><span class="line">    <span class="title function_">modelUpdater</span>(<span class="params">node, value</span>)&#123;</span><br><span class="line">        node.<span class="property">value</span> = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译文本节点，处理差值表达式</span></span><br><span class="line">    <span class="title function_">compileText</span>(<span class="params">node</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">dir</span>(node)  <span class="comment">// 以对象形式打印</span></span><br><span class="line">        <span class="comment">// &#123;&#123; msg &#125;&#125;  去正则表达式匹配差值表达式</span></span><br><span class="line">        <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/</span></span><br><span class="line">        <span class="comment">// 获取文本内容</span></span><br><span class="line">        <span class="keyword">let</span> value = node.<span class="property">textContent</span></span><br><span class="line">        <span class="keyword">if</span>(reg.<span class="title function_">test</span>(value))&#123;</span><br><span class="line">            <span class="keyword">let</span> key = <span class="title class_">RegExp</span>.<span class="property">$1</span>.<span class="title function_">trim</span>()   <span class="comment">// 获取到的是正则中 (.+?) 匹配到值，去除空格</span></span><br><span class="line">            node.<span class="property">textContent</span> = value.<span class="title function_">replace</span>(reg, <span class="variable language_">this</span>.<span class="property">vm</span>[key])   <span class="comment">// 文本节点中的插值表达式替换（替换花括号中值） </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断元素属性是否是指令</span></span><br><span class="line">    <span class="title function_">isDirective</span>(<span class="params">attrName</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> attrName.<span class="title function_">startsWith</span>(<span class="string">&#x27;v-&#x27;</span>)  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断节点是否是文本节点</span></span><br><span class="line">    <span class="title function_">isTextNode</span>(<span class="params">node</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> node.<span class="property">nodeType</span> === <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断节点是否是元素节点</span></span><br><span class="line">    <span class="title function_">isElementNode</span>(<span class="params">node</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> node.<span class="property">nodeType</span> === <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>vue.js</code>文件中，第四步需要调用<code>compiler</code>对象，解析指令和差值表达式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">        <span class="comment">// 1.通过属性保存选项的数据</span></span><br><span class="line">        <span class="keyword">this</span>.$options = options || &#123;&#125;</span><br><span class="line">        <span class="keyword">this</span>.$<span class="keyword">data</span> = options.<span class="keyword">data</span> || &#123;&#125;</span><br><span class="line">        <span class="keyword">this</span>.$el = typeof options.el === <span class="string">&#x27;string&#x27;</span>?document.querySelector(options.el):options.el </span><br><span class="line">        <span class="comment">// 2.把data中的成员转换成getter/setter，注入到vue实例中</span></span><br><span class="line">        <span class="keyword">this</span>._proxyData(<span class="keyword">this</span>.$<span class="keyword">data</span>)</span><br><span class="line">        <span class="comment">// 3.调用Observer对象，监听数据变化</span></span><br><span class="line">        new Observer(<span class="keyword">this</span>.$<span class="keyword">data</span>)</span><br><span class="line">        <span class="comment">// 4.调用compiler对象，解析指令和差值表达式</span></span><br><span class="line">        new Compiler(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 代理数据 </span></span><br><span class="line">    _proxyData(<span class="keyword">data</span>)&#123;</span><br><span class="line">        <span class="comment">// 遍历data中的所有属性</span></span><br><span class="line">        Object.keys(<span class="keyword">data</span>).forEach(key =&gt; &#123;</span><br><span class="line">            <span class="comment">// 注意：这里的this是上面constructor里面调用函数时候的this，也就是vue实例</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 把data的属性注入到vue实例中</span></span><br><span class="line">            Object.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">                enumerable: <span class="literal">true</span>,</span><br><span class="line">                configurable: <span class="literal">true</span>,</span><br><span class="line">                <span class="keyword">get</span>()&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">data</span>[key]</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">set</span>(newValue)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(newValue === <span class="keyword">data</span>[key])&#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">data</span>[key] = newValue</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Dep（Dependency）"><a href="#Dep（Dependency）" class="headerlink" title="Dep（Dependency）"></a>Dep（Dependency）</h4><ul>
<li>收集依赖，添加观察者（watcher）</li>
<li>通知所有观察者<br><img src="/posts/e3abf81e/5.png" alt="image"><br>建<code>minVue/js/dep.js</code>文件<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">class Dep &#123;</span><br><span class="line">    constructor () &#123;</span><br><span class="line">        <span class="regexp">//</span> 存储所有的观察者</span><br><span class="line">        this.subs = []</span><br><span class="line">    &#125;</span><br><span class="line">    // 添加观察者</span><br><span class="line">    addSub(<span class="function"><span class="keyword">sub</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="function"><span class="keyword">sub</span> &amp;&amp; <span class="title">sub</span>.<span class="title">update</span>)</span>&#123;</span><br><span class="line">            this.subs.push(<span class="function"><span class="keyword">sub</span>) </span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    // 发送通知</span></span><br><span class="line"><span class="function">    <span class="title">notify</span></span>()&#123;</span><br><span class="line">        this.subs.forEach(<span class="string">sub=&gt;</span>&#123;</span><br><span class="line">            sub.update()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
然后在<code>js/observer.js</code>中收集依赖，发送通知<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="keyword">data</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.walk(<span class="keyword">data</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历对象所有属性</span></span><br><span class="line">    walk(<span class="keyword">data</span>)&#123;</span><br><span class="line">        <span class="comment">// 1.判断data是否是对象</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">data</span> || typeof <span class="keyword">data</span> !== <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.遍历data对象的所有属性</span></span><br><span class="line">        Object.keys(<span class="keyword">data</span>).forEach(key=&gt;&#123;</span><br><span class="line">            <span class="keyword">this</span>.defineReactive(<span class="keyword">data</span>, key, <span class="keyword">data</span>[key])</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Object.defineProperty 把属性转成getter 和setter</span></span><br><span class="line">    <span class="comment">// 三个参数： 1.对象  2.key属性  3.属性对应的值</span></span><br><span class="line">    defineReactive(obj, key, <span class="keyword">val</span>)&#123;</span><br><span class="line">        let that = <span class="keyword">this</span></span><br><span class="line">        <span class="comment">// 负责收集依赖，并发送通知</span></span><br><span class="line">        let dep = new Dep()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果val是对象，把val内部的属性转换成响应式</span></span><br><span class="line">        <span class="keyword">this</span>.walk(<span class="keyword">val</span>)</span><br><span class="line"></span><br><span class="line">        Object.defineProperty(obj, key, &#123;</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            <span class="keyword">get</span>()&#123;</span><br><span class="line">                <span class="comment">// 收集依赖</span></span><br><span class="line">                Dep.target &amp;&amp; dep.addSub(Dep.target)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">val</span>   <span class="comment">// 不能传obj[key],不然会出现死递归，通过传第三个参数val闭包来解决</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>(newValue)&#123;</span><br><span class="line">                <span class="keyword">if</span>(newValue === <span class="keyword">val</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">val</span> = newValue</span><br><span class="line">                <span class="comment">// 如果新赋值的属性是对象进行响应式</span></span><br><span class="line">                that.walk(newValue)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 发送通知</span></span><br><span class="line">                dep.notify()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4></li>
<li>当数据变化出发依赖，dep通知所有的Watcher实例更新视图</li>
<li>自身实例化的时候往dep对象中添加自己<br><img src="/posts/e3abf81e/4.png" alt="image"></li>
</ul>
<p>建<code>js/watcher.js</code>文件</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(vm, key, cb )&#123;</span><br><span class="line">        <span class="keyword">this</span>.vm = vm </span><br><span class="line">        <span class="comment">// data中的属性名称</span></span><br><span class="line">        <span class="keyword">this</span>.key = key </span><br><span class="line">        <span class="comment">// 回调函数负责更新视图</span></span><br><span class="line">        <span class="keyword">this</span>.cb = cb</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把watcher对象记录到Dep类的静态属性target</span></span><br><span class="line">        Dep.target = <span class="keyword">this</span></span><br><span class="line">        <span class="comment">// 触发get方法，在get方法中会调用addSub</span></span><br><span class="line">        <span class="keyword">this</span>.oldValue = vm[key]</span><br><span class="line"></span><br><span class="line">        Dep.target = <span class="literal">null</span>  <span class="comment">// 添加过后 设置为空，防止重复添加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数据发生变化的时候更新视图</span></span><br><span class="line">    update()&#123;</span><br><span class="line">        let newValue = <span class="keyword">this</span>.vm[<span class="keyword">this</span>.key]</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.oldValue === newValue )&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.cb(newValue)  <span class="comment">// 更新视图</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>oberser.js</code>文件中添加收集依赖，<code>Dep.target &amp;&amp; dep.addSub(Dep.target)</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="keyword">data</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.walk(<span class="keyword">data</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历对象所有属性</span></span><br><span class="line">    walk(<span class="keyword">data</span>)&#123;</span><br><span class="line">        <span class="comment">// 1.判断data是否是对象</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">data</span> || typeof <span class="keyword">data</span> !== <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.遍历data对象的所有属性</span></span><br><span class="line">        Object.keys(<span class="keyword">data</span>).forEach(key=&gt;&#123;</span><br><span class="line">            <span class="keyword">this</span>.defineReactive(<span class="keyword">data</span>, key, <span class="keyword">data</span>[key])</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Object.defineProperty 把属性转成getter 和setter</span></span><br><span class="line">    <span class="comment">// 三个参数： 1.对象  2.key属性  3.属性对应的值</span></span><br><span class="line">    defineReactive(obj, key, <span class="keyword">val</span>)&#123;</span><br><span class="line">        let that = <span class="keyword">this</span></span><br><span class="line">        <span class="comment">// 负责收集依赖，并发送通知</span></span><br><span class="line">        let dep = new Dep()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果val是对象，把val内部的属性转换成响应式</span></span><br><span class="line">        <span class="keyword">this</span>.walk(<span class="keyword">val</span>)</span><br><span class="line"></span><br><span class="line">        Object.defineProperty(obj, key, &#123;</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            <span class="keyword">get</span>()&#123;</span><br><span class="line">                <span class="comment">// 收集依赖</span></span><br><span class="line">                Dep.target &amp;&amp; dep.addSub(Dep.target)   <span class="comment">// Dep.target 也就是watcher对象</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">val</span>   <span class="comment">// 不能传obj[key],不然会出现死递归，通过传第三个参数val闭包来解决</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>(newValue)&#123;</span><br><span class="line">                <span class="keyword">if</span>(newValue === <span class="keyword">val</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">val</span> = newValue</span><br><span class="line">                <span class="comment">// 如果新赋值的属性是对象进行响应式</span></span><br><span class="line">                that.walk(newValue)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 发送通知</span></span><br><span class="line">                dep.notify()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到<code>Oberver.js</code>中，创建插值表达式时候创建<code>watcher对象</code>，当数据改变更新视图</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译文本节点，处理差值表达式</span></span><br><span class="line"><span class="title function_">compileText</span>(<span class="params">node</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">dir</span>(node)  <span class="comment">// 以对象形式打印</span></span><br><span class="line">    <span class="comment">// &#123;&#123; msg &#125;&#125;  去正则表达式匹配差值表达式</span></span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/</span></span><br><span class="line">    <span class="comment">// 获取文本内容</span></span><br><span class="line">    <span class="keyword">let</span> value = node.<span class="property">textContent</span></span><br><span class="line">    <span class="keyword">if</span>(reg.<span class="title function_">test</span>(value))&#123;</span><br><span class="line">        <span class="keyword">let</span> key = <span class="title class_">RegExp</span>.<span class="property">$1</span>.<span class="title function_">trim</span>()   <span class="comment">// 获取到的是正则中 (.+?) 匹配到值，去除空格</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文本节点中的插值表达式替换（替换花括号中值） </span></span><br><span class="line">        node.<span class="property">textContent</span> = value.<span class="title function_">replace</span>(reg, <span class="variable language_">this</span>.<span class="property">vm</span>[key])   </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建watcher对象，当数据改变更新视图</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, key, <span class="function">(<span class="params">newValue</span>)=&gt;</span>&#123;</span><br><span class="line">            node.<span class="property">textContent</span> = newValue</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在处理指令的方法<code>compiler.js</code>文件中创建<code>watcher对象</code></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">update</span><span class="params">(node, key, attrName)</span></span>&#123;</span><br><span class="line">    let updateFn = this<span class="selector-attr">[attrName + <span class="string">&#x27;Updater&#x27;</span>]</span>  <span class="comment">// 用于判断使用哪一个处理指令的函数</span></span><br><span class="line">    <span class="comment">// updateFn &amp;&amp; updateFn(node, this.vm[key])   // 对应的处理方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的写法是针对watcher调用时候获取compiler的this还有key做的改写</span></span><br><span class="line">    updateFn &amp;&amp; updateFn<span class="selector-class">.call</span>(this, node, this<span class="selector-class">.vm</span><span class="selector-attr">[key]</span>, key)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 v-text 指令</span></span><br><span class="line"><span class="function"><span class="title">textUpdater</span><span class="params">(node, value, key)</span></span>&#123;</span><br><span class="line">    node<span class="selector-class">.textContent</span> = value</span><br><span class="line">    <span class="comment">// 创建watcher对象，当数据改变更新视图</span></span><br><span class="line">    new <span class="built_in">Watcher</span>(this<span class="selector-class">.vm</span>, key, (newValue)=&gt;&#123;</span><br><span class="line">        node<span class="selector-class">.textContent</span> = newValue</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理v-model指令</span></span><br><span class="line"><span class="function"><span class="title">modelUpdater</span><span class="params">(node, value, key)</span></span>&#123;</span><br><span class="line">    node<span class="selector-class">.value</span> = value</span><br><span class="line">    <span class="comment">// 创建watcher对象，当数据改变更新视图</span></span><br><span class="line">    new <span class="built_in">Watcher</span>(this<span class="selector-class">.vm</span>, key, (newValue)=&gt;&#123;</span><br><span class="line">        node<span class="selector-class">.value</span> = newValue</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul>
<li><p>整体一个流程图：<br><img src="/posts/e3abf81e/liuchen.png" alt="mvvm响应式原理"></p>
</li>
<li><p>Vue构造函数中做了哪些事情：<br>首先记录下来options传过来的选项，接着调用_proxyData把data中的属性注入到Vue实例中，接着开始创建Observer和Compiler，Observer作用是数据劫持，在Observer里面，把data里面的属性转换成getter和setter，当数据变化的时候，也就是触发setter方法的时候，通知变化，告诉Dep数据变化了，要调用notify方法，notify方法中要调用watcher的update，watcher的update方法中就会去更新视图，这是数据变化的时候更新视图，当创建watcher对象的时候，会将当前的watcher对象添加到Dep的Subs数组中，也就是收集依赖，也收集Dep依赖的这些watcher，让Dep将这些依赖记录下来，Observer创建完之后，接下来创建Compiler对象，Compiler对象作用是解析指令，解析插值表达式，页面首次加载的时候，会调用Compiler里面的相关方法去更新试视图，同时，在Compiler里面还要去订阅数据的变化绑定更新函数（订阅数据的变化：意思是在Compiler处理插值表达式的方法和处理指令的方法中，除了更新视图以外，还要去创建一个watcher对象，也就是订阅数据的变化，当数据变化的时候，Dep会通知watcher，绑定更新函数：当我们创建一个watcher对象的时候，要传递一个回调函数，在这个回调函数中去更新视图，当页面首次加载的时候，是通过Compiler去更新视图，当数据变化的时候是通过watcher去更新视图）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Router基本使用及hash模式和history模式实现原理</title>
    <url>/posts/67ac0156.html</url>
    <content><![CDATA[<p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p>
<ul>
<li>嵌套的路由/视图表</li>
<li>模块化的、基于组件的路由配置</li>
<li>路由参数、查询、通配符</li>
<li>基于 Vue.js 过渡系统的视图过渡效果</li>
<li>细粒度的导航控制</li>
<li>带有自动激活的 CSS class 的链接</li>
<li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li>
<li>自定义的滚动条行为<span id="more"></span>

</li>
</ul>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>根据vue-cli脚手架自动生成一个简单的带有router文件夹的项目目录</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">Vue CLI v4.<span class="number">5.9</span></span><br><span class="line">Failed <span class="keyword">to</span> check <span class="keyword">for</span> updates</span><br><span class="line">? Please pick a preset: Manually <span class="keyword">select</span> features</span><br><span class="line">? Check the features needed <span class="keyword">for</span> your project: </span><br><span class="line"> ( ) Choose Vue version</span><br><span class="line"> <span class="comment">(*) Babel</span></span><br><span class="line"><span class="comment"> ( ) TypeScript</span></span><br><span class="line"><span class="comment"> ( ) Progressive Web App (PWA) Support        </span></span><br><span class="line"><span class="comment"> (*)</span> Router</span><br><span class="line"> ( ) Vuex</span><br><span class="line"> ( ) CSS Pre-processors</span><br><span class="line">&gt;( ) Linter / Formatter</span><br><span class="line"> ( ) <span class="keyword">Unit</span> Testing</span><br><span class="line"> ( ) E2E Testing</span><br></pre></td></tr></table></figure>

<h3 id="Vue-Router使用"><a href="#Vue-Router使用" class="headerlink" title="Vue Router使用"></a>Vue Router使用</h3><ul>
<li>1.注册路由插件</li>
<li>2.创建一个router对象，创建过程中配置一些路由规则</li>
<li>3.注册router对象，也就是在创建vue实例的时候，要在选项里面，来配置我们创建好的router对象</li>
<li>4.创建路由组件占位和跳转链接<h4 id="注册路由插件"><a href="#注册路由插件" class="headerlink" title="注册路由插件"></a>注册路由插件</h4>在 router/index.js 文件中<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../views/Home.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.注册路由插件</span></span><br><span class="line"><span class="comment">// Vue.use() 是用来注册插件，会调用传入对象的install方法</span></span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure>
<h4 id="创建router对象配置路由规则"><a href="#创建router对象配置路由规则" class="headerlink" title="创建router对象配置路由规则"></a>创建router对象配置路由规则</h4>在 router/index.js 文件中<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由规则</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;About&#x27;</span>,</span><br><span class="line">    component: () =&gt; <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../views/About.vue&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建router路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
<h4 id="注册router对象"><a href="#注册router对象" class="headerlink" title="注册router对象"></a>注册router对象</h4>在main.js文件中<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="comment">// 3. 注册router 对象</span></span><br><span class="line">  router,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="创建路由组件占位和跳转链接"><a href="#创建路由组件占位和跳转链接" class="headerlink" title="创建路由组件占位和跳转链接"></a>创建路由组件占位和跳转链接</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 创建路由连接 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> |</span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 创建路由占位 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="route和-router区别"><a href="#route和-router区别" class="headerlink" title="$route和$router区别"></a>$route和$router区别</h3><p>在main.js中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="comment">// import router from &#x27;./router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="comment">// 3. 注册router 对象</span></span><br><span class="line">  <span class="comment">// router,</span></span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vm)</span><br></pre></td></tr></table></figure>
<p>先将<code>router</code>注释，查看打印结果发现没有<code>$route</code>和<code>$router</code></p>
<p>放开注释后，会发现多了<code>$route</code>和<code>$router</code><br><img src="/posts/67ac0156/no_router.png" alt="route"></p>
<ul>
<li><p>$route: 表示路由规则,存储的是当前路由的一些路由数据，存储了一些路径<br><img src="/posts/67ac0156/route.png" alt="route"></p>
</li>
<li><p>$router: 表示路由对象，就是vuerouter的一个实例，这个路由对象中会提供一些跟路由相关的一些方法<br><img src="/posts/67ac0156/router.png" alt="router"></p>
</li>
</ul>
<p>需要注意的是<code>$router</code>里面有一个<code>currentRoute</code>，这个当前路由规则，有的时候不方便获取<code>$route</code>,比如在一个插件里面没有办法获取到<code>$route</code>，可以想办法获取到<code>$router</code>，然后获取<code>cunrrentRoute</code>,这样也就获取到了当前路由的规则</p>
<h3 id="动态路由传参"><a href="#动态路由传参" class="headerlink" title="动态路由传参"></a>动态路由传参</h3><h4 id="动态传参连接跳转"><a href="#动态传参连接跳转" class="headerlink" title="动态传参连接跳转"></a>动态传参连接跳转</h4><ul>
<li>query会在地址栏出现 <code>id=&#39;XX&#39;</code>  eg: <code>http://localhost:8080/#/?id=1</code></li>
<li>params会在地址栏 <code>/xx</code>,eg: <code>http://localhost:8080/#/detail/1</code>，props方式需要用这个方式<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="comment">&lt;!-- 创建路由连接 --&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> |</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> |</span></span><br><span class="line"><span class="language-xml">      <span class="comment">&lt;!-- &lt;router-link to=&quot;/detail&quot;&gt;Detail&lt;/router-link&gt;  --&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="comment">&lt;!-- &lt;router-link :to=&quot;</span></span><span class="template-variable">&#123;name:&#x27;Detail&#x27;,query:&#123;id:1&#125;</span><span class="language-xml"><span class="comment">&#125;&quot;&gt;Detail&lt;/router-link&gt;  --&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;name:&#x27;Detail&#x27;,params:&#123;id:1&#125;</span><span class="language-xml"><span class="tag"><span class="string">&#125;&quot;</span>&gt;</span>Detail<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 创建占位 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h4>在router/index.js文件中<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">// 路由规则</span><br><span class="line">const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="type">name</span>: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="type">name</span>: <span class="string">&#x27;About&#x27;</span>,</span><br><span class="line">    component: () =&gt; <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../views/About.vue&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">path</span>: <span class="string">&#x27;/detail/:id&#x27;</span>,</span><br><span class="line">    <span class="type">name</span>: <span class="string">&#x27;Detail&#x27;</span>,</span><br><span class="line">    // 开启props会把url中的参数传递给组件</span><br><span class="line">    // 当为<span class="keyword">true</span>时，会将url中的参数传递给相应的组件，在组件中通过props来接收就可以了</span><br><span class="line">    props: <span class="keyword">true</span>,</span><br><span class="line">    component: () =&gt; <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../views/Detail.vue&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="接收方式"><a href="#接收方式" class="headerlink" title="接收方式"></a>接收方式</h4>两种方式接收（方式1需要强依赖，更推荐方式2）：<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!-- Detail.vue内容 --&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;detail&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is an Detail page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 方式1： 通过路由规则获取 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>路由规则获取query方式：</span><span class="template-variable">&#123;&#123;<span class="name">$route.query.id</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>路由规则获取params方式：</span><span class="template-variable">&#123;&#123;<span class="name">$route.params.id</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 方式2： 通过prop获取 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>props方式获取：</span><span class="template-variable">&#123;&#123;<span class="name">id</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">name</span>:<span class="string">&#x27;Detail&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">props</span>:[<span class="string">&#x27;id&#x27;</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3>在router/index.js文件中<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由规则</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;About&#x27;</span>,</span><br><span class="line">    component: () =&gt; <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../views/About.vue&#x27;</span>),</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">&#x27;detail/:id&#x27;</span>,</span><br><span class="line">        <span class="comment">// 开启props会把url中的参数传递给组件</span></span><br><span class="line">        <span class="comment">// 当为true时，会将url中的参数传递给相应的组件，在组件中通过props来接收就可以了</span></span><br><span class="line">        props: <span class="keyword">true</span>,</span><br><span class="line">        component: () =&gt; <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../views/Detail.vue&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">this.<span class="variable">$router</span>.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">this.<span class="variable">$router</span>.<span class="title function_ invoke__">push</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;Home&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">this.<span class="variable">$router</span>.<span class="title function_ invoke__">push</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;Home&#x27;</span>,<span class="attr">params</span>:&#123;<span class="attr">id</span>:<span class="number">1</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line">this.<span class="variable">$router</span>.<span class="title function_ invoke__">push</span>(&#123;<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,<span class="attr">query</span>:&#123;<span class="attr">id</span>:<span class="number">1</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会记录本次历史</span></span><br><span class="line">this.<span class="variable">$router</span>.<span class="title function_ invoke__">replace</span>(<span class="string">&#x27;/home&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转到历史的某一次，如果是负数就是后退</span></span><br><span class="line">this.<span class="variable">$router</span>.<span class="title function_ invoke__">go</span>(-<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Hash模式-和-History模式区别"><a href="#Hash模式-和-History模式区别" class="headerlink" title="Hash模式 和 History模式区别"></a>Hash模式 和 History模式区别</h3>无论那种模式，都是客户端路由的实现方式，也就是当路径发生变化之后不会向服务器发送请求，使用JS监视路径的变化，然后根据不同的地址渲染不同的内容，如果需要服务器端内容的话会发送ajax请求去获取。<h4 id="表现形式的区别"><a href="#表现形式的区别" class="headerlink" title="表现形式的区别"></a>表现形式的区别</h4></li>
<li>hash模式:<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//mu</span>sic.<span class="number">163</span>.com<span class="regexp">/#/</span>playlist?id=<span class="number">121212</span></span><br></pre></td></tr></table></figure></li>
<li>history模式：<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//mu</span>sic.<span class="number">163</span>.com<span class="regexp">/playlist/</span><span class="number">31032232</span></span><br></pre></td></tr></table></figure>
<h4 id="原理区别"><a href="#原理区别" class="headerlink" title="原理区别"></a>原理区别</h4><h5 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a>Hash模式</h5>hash模式是基于锚点，以及onhashchange事件，通过锚点的值作为路由地址，地址发生变化出发onhashchange事件，在根据路径决定页面上呈现的内容<h5 id="History模式"><a href="#History模式" class="headerlink" title="History模式"></a>History模式</h5>history是基于HTML5中的History API</li>
<li>history.pushState()</li>
<li>history.replaceState()<h6 id="history-pushState和-history-push区别"><a href="#history-pushState和-history-push区别" class="headerlink" title="history.pushState和 history.push区别"></a>history.pushState和 history.push区别</h6></li>
<li>history.pushState() 不会向服务器发送请求，只会改变浏览器地址栏中的地址，并且把地址记录到历史记录中，所以可以实现客户端路由 另外，IE10 以后才支持</li>
<li>history.push() 路径发生变化，需要向服务器发送请求<h4 id="History模式使用"><a href="#History模式使用" class="headerlink" title="History模式使用"></a>History模式使用</h4></li>
<li>history需要服务器的支持</li>
<li>单页面应用中，只有一个index.html这样的页面，服务端不存在<a href="http://www.test.com/login">http://www.test.com/login</a> 这样的地址，服务端不存在/login这样的页面</li>
<li>在服务端应该除了静态资源外都返回单页应用的index.html<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.创建router对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">&#x27;history&#x27;</span>,    <span class="comment">//默认是hash</span></span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
因为vue-cli自带的服务器已经配置好了上面说的内容，下面将代码打包部署的到node服务器中进行一个测试</li>
<li>Node服务器配置 history模式<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="keyword">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入history模式的模块</span></span><br><span class="line"><span class="keyword">const</span> history = <span class="keyword">require</span>(<span class="string">&#x27;connect-history-api-fallback&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="keyword">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册处理history模式的中间件</span></span><br><span class="line"><span class="comment">// app.use(history())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理静态资源的中间件 网站根目录 ../web</span></span><br><span class="line">app.<span class="keyword">use</span>(express.<span class="keyword">static</span>(path.join(__dirname,<span class="string">&#x27;../web&#x27;</span>))) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>, ()=&gt;&#123;</span><br><span class="line">    console.log(<span class="string">&#x27;服务器开启，端口：3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="/posts/67ac0156/router_history.png" alt="关闭history刷新页面"><br>这是先关闭处理history（注释app.use(history())），当前求地址后，刷新页面就会出错了 </p>
<p>如下放开注释，打开history支持，再去刷新页面，就可以了</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册处理history模式的中间件</span></span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">use</span>(history())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>加载过程是：<br>服务器会判断当前请求的页面，服务器上没有会把我们单页应用默认的index.html返回给浏览器，浏览器接收到这个index.html,会再去判断路由地址，然后根据路由去加载对应配置的组件，这就是加载的过程。</p>
</blockquote>
<ul>
<li>Nginx配置 history模式 mac下载nginx教程地址参考：<a href="https://www.cnblogs.com/meng1314-shuai/p/8335140.html">https://www.cnblogs.com/meng1314-shuai/p/8335140.html</a><br><img src="/posts/67ac0156/nginx1.png" alt="Nginx配置"></li>
</ul>
<p>将打包好的前端项目，复制到html中<br><img src="/posts/67ac0156/nginx2.png" alt="Nginx配置2"></p>
<p>启动nginx点击访问可以，但是一旦刷新，就会出现如下问题<br><img src="/posts/67ac0156/nginx3.png" alt="Nginx配置3"></p>
<p>这个时候就需要去nginx.config里面配置一下<br><img src="/posts/67ac0156/nginx4.png" alt="Nginx配置4"></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">try_files <span class="variable">$uri</span> <span class="variable">$uri</span><span class="regexp">/ /i</span>ndex.html;   <span class="comment">#新加一个 </span></span><br></pre></td></tr></table></figure>
<p>try_files 试着去请求当前浏览器请求的路径所对应的文件，没找到就去找这个目录下的默认首页，如果没有找到就去单文件应用下的首页（/index.html） 重启nginx，现在访问的时候再刷新页面就不会出现上面的404了</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><h5 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h5><ul>
<li>URL中#后面的内容作为路径地址</li>
<li>监听hashchange事件</li>
<li>根据当前路由地址找到对应的组件重新渲染</li>
</ul>
<h5 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h5><ul>
<li>通过history.pushState()方法改变地址栏</li>
<li>监听popstate事件</li>
<li>根据当前路由地址找到对应组件重新渲染</li>
</ul>
<h3 id="实现一个自己的vue-router"><a href="#实现一个自己的vue-router" class="headerlink" title="实现一个自己的vue-router"></a>实现一个自己的vue-router</h3><p>原文件<code>router/index.js</code>中生成的默认vue-router如下：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册插件</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>, <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>: homeComponent &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="comment">// 创建Vue实例 注册router对象</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    <span class="attr">reder</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).<span class="symbol">$mou</span>nt(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="创建router-link"><a href="#创建router-link" class="headerlink" title="创建router-link"></a>创建router-link</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">let _Vue = null</span><br><span class="line">export default class VueRouter &#123;</span><br><span class="line">    <span class="comment">// 导出一个静态方法 install</span></span><br><span class="line">    <span class="comment">// Vue.use() 中调用install方法时候，会传递两个参数，一个是vue构造函数 另一个是 可选的选项对象 </span></span><br><span class="line">    static install (Vue) &#123;  <span class="comment">//这里传递构造函数</span></span><br><span class="line">        <span class="comment">// 1. 判断当前插件是否已经被安装</span></span><br><span class="line">        <span class="built_in">if</span>(VueRouter<span class="selector-class">.install</span>.installed)&#123; </span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        VueRouter<span class="selector-class">.install</span><span class="selector-class">.installed</span> = true</span><br><span class="line">        <span class="comment">// 2. 把vue构造函数记录到全局变量</span></span><br><span class="line">        _Vue = Vue</span><br><span class="line">        <span class="comment">// 3. 把创建vue实例时候传入的router 对象注入到vue实例上</span></span><br><span class="line">        <span class="comment">// 混入</span></span><br><span class="line">        _Vue<span class="selector-class">.mixin</span>(&#123;</span><br><span class="line">            <span class="built_in">beforeCreate</span>()&#123;</span><br><span class="line">                <span class="comment">// 只有vue $options里面才会有router 组件没有</span></span><br><span class="line">                <span class="built_in">if</span>(this.<span class="variable">$options</span>.router)&#123;</span><br><span class="line">                    _Vue<span class="selector-class">.prototype</span>.<span class="variable">$router</span> = this.<span class="variable">$options</span><span class="selector-class">.router</span></span><br><span class="line">                    <span class="comment">// 先找到route对象，然后再调用init方法</span></span><br><span class="line">                    this.<span class="variable">$options</span><span class="selector-class">.router</span><span class="selector-class">.init</span>()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个构造函数</span></span><br><span class="line">    <span class="built_in">constructor</span>(options)&#123;</span><br><span class="line">        this<span class="selector-class">.options</span> = options    <span class="comment">//作用就是记录构造函数传入的options路由规则</span></span><br><span class="line">        this<span class="selector-class">.routeMap</span> = &#123;&#125;  <span class="comment">// routeMap里面是一个键值对形式，健存的就是路由地址，值就是路由组件 将来在router-view这个组件里面会根据当前的路由地址到routeMap里面找到对应的组件然后渲染到浏览器中</span></span><br><span class="line">        this<span class="selector-class">.data</span> = _Vue<span class="selector-class">.observable</span>(&#123;  <span class="comment">// 响应式对象</span></span><br><span class="line">            current: <span class="string">&#x27;/&#x27;</span>  <span class="comment">//  current用来记录当前路由地址，默认情况下是 / 斜杠</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个初始化方法 方便调用</span></span><br><span class="line">    init () &#123;</span><br><span class="line">        this<span class="selector-class">.createRouteMap</span>()</span><br><span class="line">        this<span class="selector-class">.initComponents</span>(_Vue)  <span class="comment">// 传入构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法的作用是去遍历所有的路由规则，把这些路由规则解析成键值对的形式存储到routeMap中</span></span><br><span class="line">    <span class="built_in">createRouteMap</span>()&#123;</span><br><span class="line">        <span class="comment">// this.options.routes // 所有的路由规则</span></span><br><span class="line">        this<span class="selector-class">.options</span><span class="selector-class">.routes</span><span class="selector-class">.forEach</span>(route =&gt; &#123;</span><br><span class="line">            this<span class="selector-class">.routeMap</span><span class="selector-attr">[route.path]</span> = route<span class="selector-class">.component</span> </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initComponents (Vue) &#123;   <span class="comment">// 参数是vue构造函数</span></span><br><span class="line">        <span class="comment">// 创建router-link 组件</span></span><br><span class="line">        Vue<span class="selector-class">.component</span>(<span class="string">&#x27;router-link&#x27;</span>, &#123;</span><br><span class="line">            props: &#123;</span><br><span class="line">                to: String</span><br><span class="line">            &#125;,</span><br><span class="line">            template: `&lt;<span class="selector-tag">a</span> :href = <span class="string">&quot;to&quot;</span>&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/a&gt;`</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引入自己写的vueRouter"><a href="#引入自己写的vueRouter" class="headerlink" title="引入自己写的vueRouter"></a>引入自己写的vueRouter</h4><p>这个时候页面直接去引入这个方法，</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="regexp">//</span> <span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;../vuerouter&#x27;</span>  <span class="regexp">//</span> 这里引入自己写的vuerouter</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../views/Home.vue&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后发现页面会有报错<br><img src="/posts/67ac0156/router_error" alt="router_error"></p>
<p>因为Vue的构建版本分为<code>运行时版</code> 和 <code>完整版</code></p>
<ul>
<li>运行时版：不支持template模版，需要打包的时候提前编译</li>
<li>完整版：包含运行时和编译器，体积比运行时版本大10K左右，程序运行的时候把模版转换成render函数</li>
</ul>
<p>我们的vue-vli创建的项目默认的是运行时版，所有就出现上面的错误了，解决如下：</p>
<ul>
<li><p>方法一：通过完整版来解决问题，<a href="https://cli.vuejs.org/zh/config/#%E5%85%A8%E5%B1%80-cli-%E9%85%8D%E7%BD%AE">https://cli.vuejs.org/zh/config/#全局-cli-配置</a><br><img src="/posts/67ac0156/router_config" alt="router_error"><br>在根目录下创建一个vue.config.js文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">    runtimeCompiler: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样配置后，页面中router-link就能显示了，还有一个报错，是因为自己手写时候还没有写router-view 的组件</p>
</li>
<li><p>方法二：通过运行时版来解决问题，运行时版本的vue不带编译器，也就是不支持组件中的template选项，编译器的作用就是将template编译成render函数，所有直接写render函数来解决</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">initComponents (Vue) &#123;   <span class="regexp">//</span> 参数是vue构造函数</span><br><span class="line">        <span class="regexp">//</span> 创建router-link 组件</span><br><span class="line">        Vue.component(<span class="string">&#x27;router-link&#x27;</span>, &#123;</span><br><span class="line">            props: &#123;</span><br><span class="line">                to: String</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="regexp">//</span> template: `&lt;a :href = <span class="string">&quot;to&quot;</span>&gt;&lt;slot&gt;&lt;<span class="regexp">/slot&gt;&lt;/</span>a&gt;`</span><br><span class="line">            render (h)&#123; </span><br><span class="line">                return h(<span class="string">&#x27;a&#x27;</span>,&#123;   <span class="regexp">//</span> h函数 可以接收三个参数，<span class="number">1</span>创建元素的选择器 <span class="number">2</span>.设置属性 <span class="number">3</span>.生成元素的子元素所以数组的形式</span><br><span class="line">                    attrs: &#123;</span><br><span class="line">                        href: this.to  <span class="regexp">//</span> 传的props中的 to</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, [this.<span class="variable">$slots</span>.default])   <span class="regexp">//</span>this.<span class="variable">$slots</span>.default获取默认插槽的内容</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建router-view-这个组件"><a href="#创建router-view-这个组件" class="headerlink" title="创建router-view 这个组件"></a>创建router-view 这个组件</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">initComponents (Vue) &#123;   <span class="regexp">//</span> 参数是vue构造函数</span><br><span class="line">        <span class="regexp">//</span> 创建router-link 组件</span><br><span class="line">        Vue.component(<span class="string">&#x27;router-link&#x27;</span>, &#123;</span><br><span class="line">            props: &#123;</span><br><span class="line">                to: String</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="regexp">//</span> template: `&lt;a :href = <span class="string">&quot;to&quot;</span>&gt;&lt;slot&gt;&lt;<span class="regexp">/slot&gt;&lt;/</span>a&gt;`</span><br><span class="line">            render (h)&#123; </span><br><span class="line">                return h(<span class="string">&#x27;a&#x27;</span>,&#123;   <span class="regexp">//</span> h函数 可以接收三个参数，<span class="number">1</span>创建元素的选择器 <span class="number">2</span>.设置属性 <span class="number">3</span>.生成元素的子元素所以数组的形式</span><br><span class="line">                    attrs: &#123;</span><br><span class="line">                        href: this.to  <span class="regexp">//</span> 传的props中的 to</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, [this.<span class="variable">$slots</span>.default])   <span class="regexp">//</span>this.<span class="variable">$slots</span>.default获取默认插槽的内容</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        const self = this</span><br><span class="line">        <span class="regexp">//</span> 创建router-view 组件</span><br><span class="line">        Vue.component(<span class="string">&#x27;router-view&#x27;</span>,&#123;</span><br><span class="line">            render(h)&#123;   <span class="regexp">//</span> h作用是创建虚拟DOM</span><br><span class="line">                <span class="regexp">//</span> 找到当前路由的地址 根据当前路由地址，去routeMap对象中，找到对应的组件，然后再调用h函数，把找到的组件转换成虚拟DOM直接返回</span><br><span class="line">                const component = self.routeMap[self.data.current]  <span class="regexp">//</span>获取组件</span><br><span class="line">                return h(component)   <span class="regexp">//</span> 调用h函数，返回虚拟DOM ，h函数还可以直接把组件转换成虚拟DOM</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个时候去页面查看，没有报错了，可以显示了，但是当点击切换的时候，页面会刷新,需要给这个超链接注册一个点击时间，取消后续执行，还需要将地址栏中的值，改为超链接href中的值，就需要history.pushState()方法</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 创建router-link 组件</span><br><span class="line">        Vue.component(<span class="string">&#x27;router-link&#x27;</span>, &#123;</span><br><span class="line">            props: &#123;</span><br><span class="line">                to: String</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="regexp">//</span> template: `&lt;a :href = <span class="string">&quot;to&quot;</span>&gt;&lt;slot&gt;&lt;<span class="regexp">/slot&gt;&lt;/</span>a&gt;`</span><br><span class="line">            render (h)&#123; </span><br><span class="line">                return h(<span class="string">&#x27;a&#x27;</span>,&#123;   <span class="regexp">//</span> h函数 可以接收三个参数，<span class="number">1</span>创建元素的选择器 <span class="number">2</span>.设置属性 <span class="number">3</span>.生成元素的子元素所以数组的形式</span><br><span class="line">                    attrs: &#123;</span><br><span class="line">                        href: this.to  <span class="regexp">//</span> 传的props中的 to</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="regexp">//</span> 给a标签添加事件</span><br><span class="line">                    on: &#123;</span><br><span class="line">                        click: this.clickHandler</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, [this.<span class="variable">$slots</span>.default])   <span class="regexp">//</span>this.<span class="variable">$slots</span>.default获取默认插槽的内容</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                clickHandler(e)&#123;</span><br><span class="line">                    history.pushState(&#123;&#125;,<span class="string">&#x27;&#x27;</span>, this.to)  <span class="regexp">//</span>三个参数：<span class="number">1</span>.data 将来触发pushState这个事件对象的参数  <span class="number">2</span>.title网页标题 <span class="number">3</span>.url地址</span><br><span class="line">                    </span><br><span class="line">                    <span class="regexp">//</span> 将当前的路径，记录到data.current里面</span><br><span class="line">                    this.<span class="variable">$router</span>.data.current = this.to</span><br><span class="line">                    </span><br><span class="line">                    <span class="regexp">//</span> 阻止跳转默认行为</span><br><span class="line">                    e.preventDefault()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<p>现在就可以点击了，不会刷新了，地址栏也会跟着点击标签的href所改变了，虽然现在可以，但是当我们点击浏览器前进，后退的时候，地址栏发生了变化，但是组件没有发生变化，因为前进后退的时候，没有重新加载地址栏对应的组件，下面通过popstate进行改进，当历史发生变化触发，到这里模拟router的history模式就搞定了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解决前进后退 地址栏变化组件不变化的问题</span></span><br><span class="line">    <span class="title function_">initEvent</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="function">()=&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">current</span> = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span>  <span class="comment">//路径部分</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>完整代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">let _Vue = <span class="literal">null</span></span><br><span class="line">export default <span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 导出一个静态方法 install</span></span><br><span class="line">    <span class="comment">// Vue.use() 中调用install方法时候，会传递两个参数，一个是vue构造函数 另一个是 可选的选项对象 </span></span><br><span class="line">    static install (Vue) &#123;  <span class="comment">//这里传递构造函数</span></span><br><span class="line">        <span class="comment">// 1. 判断当前插件是否已经被安装</span></span><br><span class="line">        <span class="keyword">if</span>(VueRouter.install.installed)&#123; </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        VueRouter.install.installed = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 2. 把vue构造函数记录到全局变量</span></span><br><span class="line">        _Vue = Vue</span><br><span class="line">        <span class="comment">// 3. 把创建vue实例时候传入的router 对象注入到vue实例上</span></span><br><span class="line">        <span class="comment">// 混入</span></span><br><span class="line">        _Vue.mixin(&#123;</span><br><span class="line">            beforeCreate()&#123;</span><br><span class="line">                <span class="comment">// 只有vue $options里面才会有router 组件没有</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.$options.router)&#123;</span><br><span class="line">                    _Vue.prototype.$router = <span class="keyword">this</span>.$options.router</span><br><span class="line">                    <span class="comment">// 先找到route对象，然后再调用init方法</span></span><br><span class="line">                    <span class="keyword">this</span>.$options.router.<span class="keyword">init</span>()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">        <span class="keyword">this</span>.options = options    <span class="comment">//作用就是记录构造函数传入的options路由规则</span></span><br><span class="line">        <span class="keyword">this</span>.routeMap = &#123;&#125;  <span class="comment">// routeMap里面是一个键值对形式，健存的就是路由地址，值就是路由组件 将来在router-view这个组件里面会根据当前的路由地址到routeMap里面找到对应的组件然后渲染到浏览器中</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = _Vue.observable(&#123;  <span class="comment">// 响应式对象</span></span><br><span class="line">            current: <span class="string">&#x27;/&#x27;</span>  <span class="comment">//  current用来记录当前路由地址，默认情况下是 / 斜杠</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个初始化方法 方便调用</span></span><br><span class="line">    <span class="keyword">init</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.createRouteMap()</span><br><span class="line">        <span class="keyword">this</span>.initComponents(_Vue)  <span class="comment">// 传入构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.initEvent()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法的作用是去遍历所有的路由规则，把这些路由规则解析成键值对的形式存储到routeMap中</span></span><br><span class="line">    createRouteMap()&#123;</span><br><span class="line">        <span class="comment">// this.options.routes // 所有的路由规则</span></span><br><span class="line">        <span class="keyword">this</span>.options.routes.forEach(route =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.routeMap[route.path] = route.component </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initComponents (Vue) &#123;   <span class="comment">// 参数是vue构造函数</span></span><br><span class="line">        <span class="comment">// 创建router-link 组件</span></span><br><span class="line">        Vue.component(<span class="string">&#x27;router-link&#x27;</span>, &#123;</span><br><span class="line">            props: &#123;</span><br><span class="line">                to: String</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// template: `&lt;a :href = &quot;to&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/a&gt;`</span></span><br><span class="line">            render (h)&#123; </span><br><span class="line">                <span class="keyword">return</span> h(<span class="string">&#x27;a&#x27;</span>,&#123;   <span class="comment">// h函数 可以接收三个参数，1创建元素的选择器 2.设置属性 3.生成元素的子元素所以数组的形式</span></span><br><span class="line">                    attrs: &#123;</span><br><span class="line">                        href: <span class="keyword">this</span>.to  <span class="comment">// 传的props中的 to</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="comment">// 给a标签添加事件</span></span><br><span class="line">                    on: &#123;</span><br><span class="line">                        click: <span class="keyword">this</span>.clickHandler</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, [<span class="keyword">this</span>.$slots.default])   <span class="comment">//this.$slots.default获取默认插槽的内容</span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                clickHandler(e)&#123;</span><br><span class="line">                    history.pushState(&#123;&#125;,<span class="string">&#x27;&#x27;</span>, <span class="keyword">this</span>.to)  <span class="comment">//三个参数：1.data 将来触发pushState这个事件对象的参数  2.title网页标题 3.url地址</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 将当前的路径，记录到data.current里面</span></span><br><span class="line">                    <span class="keyword">this</span>.$router.<span class="keyword">data</span>.current = <span class="keyword">this</span>.to</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 阻止跳转默认行为</span></span><br><span class="line">                    e.preventDefault()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">        <span class="comment">// 创建router-view 组件</span></span><br><span class="line">        Vue.component(<span class="string">&#x27;router-view&#x27;</span>,&#123;</span><br><span class="line">            render(h)&#123;   <span class="comment">// h作用是创建虚拟DOM</span></span><br><span class="line">                <span class="comment">// 找到当前路由的地址 根据当前路由地址，去routeMap对象中，找到对应的组件，然后再调用h函数，把找到的组件转换成虚拟DOM直接返回</span></span><br><span class="line">                <span class="keyword">const</span> component = self.routeMap[self.<span class="keyword">data</span>.current]  <span class="comment">//获取组件</span></span><br><span class="line">                <span class="keyword">return</span> h(component)   <span class="comment">// 调用h函数，返回虚拟DOM ，h函数还可以直接把组件转换成虚拟DOM</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决前进后退 地址栏变化组件不变化的问题</span></span><br><span class="line">    initEvent()&#123;</span><br><span class="line">        window.addEventListener(<span class="string">&#x27;popstate&#x27;</span>, ()=&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">data</span>.current = window.location.pathname  <span class="comment">// 路径部分就是/斜杠和斜杠后面的部分  eg: /home</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端适配</title>
    <url>/posts/783ce8a9.html</url>
    <content><![CDATA[<h2 id="移动端适配的方案"><a href="#移动端适配的方案" class="headerlink" title="移动端适配的方案"></a>移动端适配的方案</h2><ul>
<li>通过<code>Meida queries（媒体查询）</code>的方式</li>
<li>以天猫首页为代表的 <code>flex</code>弹性布局</li>
<li>以淘宝首页为代表的 <code>rem + viewport</code>缩放</li>
<li><code>rem</code>方式<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3>它主要是通过查询设备的宽度来执行不同的 css 代码，最终达到界面的配置。核心语法是：<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">@media 媒体类型 <span class="built_in">and</span> (媒体特性)&#123;</span><br><span class="line">    <span class="comment">// css 代码</span></span><br><span class="line">&#125;</span><br><span class="line">媒体类型：</span><br><span class="line">    screen     ====&gt;  用于电脑显示屏</span><br><span class="line">    print      ====&gt;  用于打印机 </span><br><span class="line">    projection ====&gt;  用于方案展示，比如幻灯片</span><br><span class="line">    ...</span><br><span class="line">媒体特性：</span><br><span class="line">    max-width</span><br><span class="line">    max-height</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
例如：<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">@<span class="function">media screen <span class="title">and</span> <span class="params">(max-width:<span class="number">320</span>px)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 屏幕宽度小于320px时候 */</span></span><br><span class="line">&#125;</span><br><span class="line">@<span class="function">media screen <span class="title">and</span> <span class="params">(min-width:<span class="number">321</span>px)</span> <span class="title">and</span> <span class="params">(max-width:<span class="number">375</span>px)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 屏幕宽度大于等于321px时候代码生效 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="flex-方式"><a href="#flex-方式" class="headerlink" title="flex 方式"></a>flex 方式</h3>以天猫的实现方式进行说明：<br>它的viewport是固定的：<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no&quot;&gt;</code>高度定死，宽度自适应，元素都采用px做单位。<br>随着屏幕宽度变化，页面也会跟着变化，效果就和PC页面的流体布局差不多，在哪个宽度需要调整的时候使用响应式布局调调就行（比如网易新闻），这样就实现了<code>适配</code>。<h3 id="rem-viewport-缩放"><a href="#rem-viewport-缩放" class="headerlink" title="rem + viewport 缩放"></a>rem + viewport 缩放</h3>这也是淘宝使用的方案，根据屏幕宽度设定 rem 值，需要适配的元素都使用 rem 为单位，不需要适配的元素还是使用 px 为单位。（1em = 16px）<blockquote>
<p>rem是CSS3新增的一个相对单位（root em，根em），这个单位引起了广泛关注。这个单位与em有什么区别呢？<br>区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。比如：p{font-size:14px;font-size:0.875rem;}<br>(推荐一个单位转换的工具：<a href="http://pxtoem.com/">http://pxtoem.com/</a>)</p>
</blockquote>
<h3 id="rem-方式"><a href="#rem-方式" class="headerlink" title="rem 方式"></a>rem 方式</h3><h4 id="为什么html的字体大小设置为font-size-625"><a href="#为什么html的字体大小设置为font-size-625" class="headerlink" title="为什么html的字体大小设置为font-size:625%"></a>为什么html的字体大小设置为font-size:625%</h4>浏览器默认字体大小是16px，rem与px关系为：1rem = 10px，10/16=0.625=62.5%，当设计稿和屏幕一样大的情况下（如750px），只要将设计稿中量到的px尺寸除以10就得到了相应的rem尺寸，例如：100px = 10rem，120px = 12rem。但是在项目中设置成 font-size: 62.5% 在大部分现代浏览器都没有问题，在谷歌浏览器可能会出现问题，因为chrome不支持小于12px的字体，最小就是12px，计算小于10px的时候，会默认取12px去计算，导致chrome的em/rem计算不准确。谷歌font-size:62.5%刚好是10像素，而谷歌是不支持小于12像素的字体的，所以，谷歌无形当中将所有的rem全部变大了。chrome在字体小于12px时都当12px 处理，也就是设置62.5%相当于设置成了75.0%。但是在除的时候又是除的10得到rem值，就会有问题了<br>针对这个现象，可以尝试设置html字体为625%，即100px，body修正设置为16px，这样 0.1rem 就是 10px，而body的字体仍然是默认大小，不影响未设置大小的元素的默认字体的大小。<h4 id="JS动态修改配合rem适配"><a href="#JS动态修改配合rem适配" class="headerlink" title="JS动态修改配合rem适配"></a>JS动态修改配合rem适配</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算屏幕宽度</span></span><br><span class="line"><span class="keyword">let</span> W = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取html根标签</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable constant_">HTMLDOM</span> = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;html&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置根元素字体大小</span></span><br><span class="line"><span class="variable constant_">HTMLDOM</span>.<span class="property">style</span>.<span class="property">fontSize</span> = W / <span class="number">10</span> +<span class="string">&#x27;px&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>移动端适配</tag>
      </tags>
  </entry>
  <entry>
    <title>前端知识小册纲要</title>
    <url>/posts/e5b77e85.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码不正确，请重新输入." data-whm="文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="aaa2d859933cc163d5d666a0552026aa83354ee5d40c0a3717add6fffe31153a">17722e3237e47d1ff24ecceb173bf7da94e27a41fb2bd5718bb61dd30c987daf79f6e0a94c26b0bac82a19b05ff1fab34e48ae003a6b9f4ec083e7fd9681030f7f555c264f503dc775a7b720ebf456c2494644347c8c43c62deb1c52eba8a1d45584df239dec0e5b7a5f723dda57d3d4547e3a26ce280d538e63c3de0391c68d6e631aa0a60267f051d1acf47cb36a049bf2ee41c2fb43c7c6ae829adf131c8cf96b79a43f25fd0172713e1fd6aba64772be0dbeb28d11f5419f9cc68f40a556cac08fb1470dae48cb924de190991c672eb481cd7c0b864deffb479b8f92d20233ba447f67ffab03efe3b177876264628432045840ab648269d315e13f74cee51af4c51371f0d4e047bacc5813408d6b50ab81c95f3935c2a7873c5c2c493b67f690d587abfc42db969978b029e3316da15d1e8d9d854b288388d71086316e9e9ffc62fc863feaeeca52ae140abdcce69fe801b63ce36b043e6c19e623912fd82e2c73e64b1443854410f6dd884b5faf0e9c3c76b17f9f597ccc35981941a9e279de2fca4c40a72f00c1b17a9194ad750d35e7989000024a2f87c3721c8a48578695a784f7746cfc8efcfed8b7427be9de1f434178ad5805c713c9f04d986745e5bf818bb280510ce8f6b760455f076535097c5301683260a7b79e25e207a12374ec3aa4c9e6296de7ef02d7d9ba242c6bf429ea38ca7800d9c5e0ff0149cc7fda876d57f2f718cb770c5038c8586fba0ff77bff354d4650617bcec2618bd0d2285f8709a62aef50c2b7a61ae5cdff706b2dff2b03e0647795739866502a49a6303af1e6cf30aa62abcd84d433e1b8b2da2edd1fbe83f403bd1c69c5cbcc66a2f9e5980dc58acf104522b500fb764cbdbdd146210bf5af26c54377814c3afa429c852f804b5f54f84b401e94829e59daaaeedff154c61dbbd5d1d014c3f221ef381935a12831c999a71143ebd47981839a555ba22919d77e5ff079a76eb285a61e162799b8565fc17db9e5b61fba6162ca9108d3c0d2ebe19dff3fb46b90b46f0b540e9696390b84fc860a18945fe84225127c6ade0fb987eb37bb0af00226fe3bb3f19fb5f8af21f6308e20b6c4b3472770dbbc5b8b4d11874acb2830781b4edec7be025201b15294e53ae51bba37cf1f2e8ac35a0b291220338838054d3bd9da450d17569742c1da932947db6aa9b035d4235e04776f231e4b77c5c79c6b52c20045f986ff38aabd75e48ab09203a9b93690f16dbf7abc3025f5852734e039f248cde2a27cabd48f7d2ac2fc994a0ee3422675ed6abf4a9132f3c03591f9213464f0c1952e030fe42a134988a8135e89f3a3a10e0d76230f3445277069633c4e8a6e6c4ea3229a4799ec60f8e49de31cf41a6fb1307a7dcbfa7e76f20188885389b73aa84112a87b0aea65ffa132fee5c6ad9b161d248d60844511ceeb0a02cb3cd029be452184ce377ca099ddfc4ccba77b73d476f6139b3b134f1f4cf4d3c3610fb3e1413003fae8942641cfdf5f828bfd52532852f0aebf7850608c192b6b88d696a26c15b0795af9faf7d1fb32e827f94a3900368124dd408a5c9da8dab14e40fc2b94f7c825ab6af273b46e5132bc3c4f909837ef4f099a8c18466a0c4251d38a4ded7a69b8ffea1b97fe908ab26affe2d247c203bc903e7d3e71d3ccf21c68e0016e9b1dd9aa14a1aad18c318aa04d7c6b419e72334a4a6dae9e11b1bfd7adc8186910fe2c48a6ab180508990090d8f4761af343dbcaaed364596420c1435cbb0cfa683054512c7d29b4099b4ca278dba6d546027efdc31e016bf9b8f3e097f9083c25a6980271d986fbd5cda8ad4ee9190bae0c4cc25ed29240e588fd0f0f543b2f3e2c263e4e7953c63f12d95507f75ee763ea2dbc5b7a2b4b249031333ca432655d4e99a4cedf3941e1fa5240fbdcc23497a171fee9be180fd69b832ec1f7c26ff64db1be6cc4a68d4b722485cb551d03dcf7a23572cfe607dc669f9e962b93e66af63d1c045b981007132a26c2f76f9db86c3eb028168a7c65ebb2a7e203ff957d3099d36652affe6b5a243b69d8f46d88431516362dff7d7ed7d829884a01f159e42fa71882afac40b5f437252db4e23d8617d9efb2dcbdf892aab7f5b87aa777d50cd5a2b46d9d654bb48e0b99dddea1d72b27c33c44a345c6f46e2ec17186fa65da75c5abb4eb82bb17679f2d1ed2c9084270e876f04a36ef6a92ee8cd5de1b0b9fcf862efdf5b6e2e1c4c252e26e02308169d3a1d40a858d76e632699913b94ed78a45cda913bc759434cd0ebcb9cba79869a6c4fc8319a7c85d597319d683ca885b87346e4c868d4ad7cd67224b335986db55ae354744fb5fa612a086ffdc138e5ca070bfbe37dd30ffdbcfbb9a4d44cc729cfec11f435caf3b489312631d2853b2bb8a28d3ad31b42f363949993c5308d19733c6d9b539d7337b634427cb721446f0da8adb084afeef02f3bb89f027e2ea3ecab60c917a2a296642a92f336f972ee8f70835ec4d254c7cc372ccc213621aeb07e8338d5ae97adef4bb6814e6bfbf4f56b44ff13778532015e62fcd7fd5c7288d1ecd22d1624f7eb8ef950387e220a79b951cbaab2e677ddf361643bd558b5bad65b274c1a09cf39f2b1cee5cc756d132c122c7cb512f09d2977497f5a12da5959cecd94f49a48196811edd4bbdd31459d2db3618b3d9206869231ac30d331a9130541c6a29829e878ce15dcdb821db7968ebb9786db170c9210dfaefbd90e1498a5f119827ba1d9b807e1d54d1980854cc21f4e504f5e1ff698d77d5350b1d9152565bbe13eddac6afae31c2d3b6e15214b475286c834ef6556fa18ef55a994c6036d23180f6cdda98b7c90871fd00902168df169f7f09320586eafa3f912c29f366deebd55dc79136e3576698027302f9888fb081037ebcce1ec52235e3e71831bb00024a013933a62ca328cf4bf4d9314a9d8b8822a19ba91e351b291c0b7279b0e7379d7b8a4f3591e1e1501c3fa89882704c364786997936cb7ae9b1672b5dd390942a260cbd6ce4adfc40cdb757454b5f2ff36dad76bf0557a97572ceec0e7f490a6aa1620bad848625b1f22eca50489f9887cd33c36084e60cf180fc25151049112bcbe437fcee74095498e144f927965947f719d7a9b1c5318a321a0f5b098960b691872e47da3d8b1bef57d712c24fd65cd3dfedc5f2354e2dea3e012336bf77fb4e19ce42c09a4d61cb4857e1e6ef441fe1d0a7f05c69381e89fd13179b277cad15fa096660cc6852645c5ab0100297254dfc6ecd338ac43ac8f35f608a87388a07d517a13de257cf05706a8f8b3ec0fada55b2ceda99fb01bfb79faa93fc8607b8dd10c1b0ec2462d9579038d0be05677f0393ae124b79e361d34ee0cdb008175e950a1cdbd46b4f7f0d7ed2ffb810bd9dc1d709b14e559bc3a03be6b52c93f5454774482d425d18cb52fa071b3e22a65acadd8ed12ed4f4f9f3afa183cb8eeb121d18635f0f5905e0c7837d25f09584112c0b0d2f468aa90b51819a07dceaf64eb7d6fe022797e4e4895a1b7424d4826b0ba4ed3fb30e3713c7569d5f30e8e195ef8f357a3c88e757a15812bd2ff9340bb820745ba5868b93a9a0bac13cbf83feb0f610d7fd1655181423f22c8521ae7244358f68f3d36b9c71ada098631431068d0efb5941af56151e062f9714d579ecfabf7028c322a29f5e5be61c2758ea68be01178f5f20a45675e1eff75c2b7f18c91a72f015ff3e7ca7f11ba038d3931d6128551b6b283e68cad36adb28d733fe093eb45801d7940c59bf3e1a135bf82b5c725e9a55a19fde757bad9572f1324a07a8fd64ea52dcab8259f9bc659221b0f8457036add3bd0ffef4bfa51594898a981480cb1e9a62f1a2cbfe7a9f410363317513039a9d40d098b19d526628aa08fa9030ba2a522bfb74b09ece5f4e8d911b6279392e0a0e4144420011546b087a04e54747c0c4aeefcb6d89ba0332410a7ec7e701fb2b51d41ebfcca570cb98a275e4feb461c8c898c7581dfccbb088053a27156213c017e3fd436a69a18e19df0013c062f55ab8b4b1e280aa9af7fae4d7ae7108994424149b717e084a355e3b00d2e15e77b4077b15bece5d754cef0d78703a993e9ca54360186b80a4a66f7ebde5445d659981513f2276dafb89fde8e82911244098351b001087edce6b47836c78be76769433799d3cc622e297721cc1f6cdc6646f6382619e0e865f38de1ce92c0d0c9f6cb76cb6a3895b2a11072e5c69f2c9435e3481157d120ac8441bdb886413a09d7d89fafd029a000aa1748711b42f68008ada33becb850af94a88ffc122b89d55da78646ea8a3dac3d7607951a59d0b1339ef6a51f87dee03bbd46f86107f8ad6b3306a4f4e8caf44019cfebd055c95a3e86b9c93bf58c7f1949e786d068c583a1e272545e7dbd3643289e069b370843e9902bee0b62aa79e71014b24f40c5a12f55cef9d65a5211de845f6c3da9c13a7c304f382aa298e54737fe176bf60bf3850ec63c42a2da24f9a4e8b505ab6efceca5bde360c45e52955e1e46674619ab0d59eb696a02e93ab2ca5ca964e35519af5c6bf5ada554605547d6dc9c303ce9988d72eec1e00e51090417ded5da1250e9b0d176efddec724821a924a3a56fc84492b17be1f3e4714d67661a1cf7cf875df09a2e88d323f45ceaba775c03516fb82ffeb4ecf33603941b3d2bf14369c2de3c2078ca97b190b1260d9496c68fad4b07a4d64df536d0e2bf4645c4db66c1850c2492193e80e819a464bc60b513f512b1bd8e148b05bcf443a0122988ee9ce5fb70be380d9893ce666351790ccdbba00e4e56ff2be5b3d71a622df65d00884f1af4ce228db88aa96a91beded482d5be93d9bf894164316bcb516ee0852a305aab20f314d21c6008e89e50b6401a2ac145c5cfe0ef5f17ccdd6a284919be41cccd3f08c647dd39d159b38b7ba7a6f8f96143a0a98d21367efb1c08116a8ab2dee4dfcc7e1ba82370244343d3fff13fd2996392bf7a99adb677d2b36ab8fb2945fdafe85f4262e850aff0e94f16b34fece7211674e31bcdff4f1a62538e1a1a3e2be2e8a729da403d9dfef3e99d30ebb5f4d5828a3534423c81e0b84957af23ab8b2dd0f2b886b9939883ef8533c3b3583791a4479c38623010a890e7f7f84bfb4a670c134ee9a966f7e157294c2c39631104d26ab3831e545f4d025d73dd4694ee28a19690e111790486827e7f165f51d3647a67f3fb61c56c4e7622205f954018fff01654c3ce53f6a7eb4dbf9ff29f1757d5ec453843d3bca5356fb43332be7e2c0e7051f09697c27912162e2e072d40d1c1f4404cc0a356c63cb2acabf3ccae4b6b8b69ab90e630de15325a87812af84a1db4061090ffbb624d87bf32640ac7901a6830ca99f410372cb2636a8a5c21614324a0a18dbeaa7ed930d9640b0e8e58777d0e5d427d8e832b5ae9efed0aff0546f77b5f82e8b0a2391fabc0191d242d40040294d30845a48bf7609889d699e2ea79b892585ce56fc931ad02fc5974d5ae9aa09f78665392b7acd44d0dfb7eea9672b21911ec3018d024c8e456044c987d4c7165996326b2ba40bb311377791c2e4b9de8bfed62694dc67b505fb616328861a91d0fd937072c6166d051ccc2e4c805adc85fbd5bb1c6eaab3447aa54ea26a447fb98a95d9c925e949efb8d8148053a27fd246314b14ef199ff4d7c9e7740970841ecabf16c9b854f94ddec0d4b23303e373aa38e238c0410f584314e7d254574538998335aa9eac29414d0d494a63f78a4728c69807fabc1fbd30265fefc0d973c46d819fb188c60e4ce473eff904a10269f23abea7e615f7bc2b4d626d7678229dbdb09bef09baf4373e6d5247e2871df2082401936028d9703da3c164307ab60e30842b8832e9c438c4c3fbcd9275d89b42962249a4da15736ace7d801728fd7001a19380d7299640fbce5334ebad2c17baaf917b4eb7c179e51d8a5ee677f6c708e327a78cdc62fdf7b97af1fa2700d7a1eca730db9d9de613731916de4fd68a4e871a763c08ec735ef4915fb701ca4ff2512f37a782f36bd80d71ec7220f57a8127624d9c4009050a99907ceebfd0dc8ea69605716112eb8c09a2fb8b89f655b25773b73557a07fa8ddcd930cfc969bb991b55a39af7717f21344793301f8a09f475c01aaa2831074e8e96db58b573f5a3315398133b37158f6d50d01c4c6f5f27d52a84da75c52f96f5d1c80cb80f02914c9221c98aa722f84f64ad3f840232777929c985731cf413ee7f0b10e8239a76833b51d38373c45aef8d4fd388516686365f0ad492bc3accbce1e4c85635cc174f4829b116d214001c1c1f5bbbaabc8b649809f7ed6b74b4839d388fb5d8c5065a26c065f6253dffee0ed5b990981db0131bdefdd51f164c87ea167dbe3707602a5f8475df6e05b18e02abf607e664f915cf9df8dd4aee8ec079e3c9a96a4aa1853b2f476e3ed970814eb99ee1a6c57c4385f5dc97c643dbcf18395901c7f3c13f1570d3b1575aa2bffcd41edcb7049d8cf18c825b65d135f77c4e577bc76e33ef5695e4dfed9f90da2441d220065c73c687122348df0de9629cd43ba57baceb00d3d50570297ecd5b23f265ca32fc57c9ed9b30707f23e7134784a5a0eedf1c70ac93c047c4ac6679ab9399dc0fa68b6220f9a21d014c978c717a83b20eff6c3cbb0693d4398dbd987deb7bfc9c0959fbd86799f40b473a7f63449c22f62c06c5c8fcb169ae4d422f2f3b6b4313358621df01204bafb0f97305c226163a87545e3fa85246897d0366daec00f21db4128944dc91ae0da90f5b248a33d5a6688f990370c5f5d3ede05f49cce7a0766227be5dc34589c30b6b165110bfb50dbe0a52748931e9d017c419d9b9c0b1346c240206410015cab2aa49f520762105aec06e4ddfa6dc941a29be132294fe88f37a128044a941b6e7471bf6f63d79db2e29f8e15c0060ec2c072a2f8a973aaffaee663c8f8c515afa4041abcbaba04ae8e19edabeb478a83916525efb5e664790653db70be67cbe3f675343b70c9c2e046ab817cdbd18e368a36f5e49208a44a5f1653a67c912864827fdabfaaa6054d8f700ae828d372dd9c14213b0ef4ce3fe280858ba590a9ded22ee27bf5de562d201d7cdf4f65ba7ea74c1b5b8b8668b8612c0ee6e2494bc8a2add3949981ed9e97c69109dfd8f6fc171ba0c07d93140d9b5a4712844d028ac5802f7bb76ae79cde1f4a0eb0703eee0adb7cce5e81a0d953cfe825e183e8f6f2d3eb5d66a1a2c84ccbb5dc1d884d947f6d007b825bae7f0d5e0d08aa4ffea391d3694475844e2d535056a43a45d82875f921a245452c166aaad2a192e625322a6baf0bb3d4c9ecd092b3cb4ba3fbddfabf4daa4c952fc4286977bd2bae4b74370e4fa4e7a5e453dda0ed2c3589654a204539514be1bd055dcb130077a29914fa099b1cfd721edb3d18946a4d4c90ae9af05fd1b356daa403739ba2a704829fc77df01035275bfdb0a75813c90a8096b3b416eca59c9d62c0bae5d6b4c7511ffe25d40e41d5997af2d3197b38792c8a7c52dd9212f8684f85188e234b129c290bc2ae3dd2134bd243e5ae1e4ebb1c638b2b4830604681f711c3fc289fe87f4026f30d2163f7679ab6a023952e0bb7e7d57fb26a217b58f4ab2a99b313b5c8c5821d08bbc3918f8ed1d615d855805223f356863da2b08b45d3f20e3d542d6faca5fd1a9e2a665904efa515cdee9a47351d9a432ce5b249facc898a2c452d94728d9a7b9fc52dd16cb2c39623626d99a90c405fabf3c745d90e7e41dd3b3248ce237f6a52c3719d0c1d621569baffb774b85abc031929b9b1361b7a28bac56eb5eb5395789f6030f69e662b960d0852886d096b3a0842304a12d2afa07ecdd5c27ecf3aa3bf5f496de8cc7beb260525069709f1f6f763a482cde0511e74d6045dbafdb43b9504c0dbf26c22aaa7c81f3bdf43faf832569c1c3251e4a9fccf4c26d19e4ac1dc3a3cb2c66480910d4649ecc9fc290b75b11e792aae23eb94ce8bd0035d37b95ccbf3b99041945184525bc7e7a30f0ebb787e5f70ff6fb3042d6f3ace3b6bf947eb9ac3a81d8d2c394f62a2299b39e974ab75b0b337f03d37aaef694c94f25cefea647e4dae795988a1e6a3d4f4b615e15858c012f4eb46aacdbeebeb09b9c55879db9a3a54fdbab4c25b3590d8540f1b86ba20c5a191ff5fa7b6550d3ac4ea0ce6a950f2bd7963f78cd9390d52efe4df29ae276838e23ab084edcc195b9f20cd3850b98c7e289d1f13200094802ae1b8378b8872a4afce32fbbe361e66930cf2d0fc84a4a2ee91a2b23a7f81d27172e28be90bc0e204fa7f92f583dba001c925d4eac29b2f0b8f9d7a28f5f7139b5f51d160fd72a399b984d1248605c9832c66d7e0e077f82e0adc6f1df6d8dbfd23e9a3f2ad35175fda70370b10cc099a7b8efa5bd74a755c1e98017e0aea7894bec870895ae2f3a875cc2ab639a37b2bd2d352fb65b7a35cac5c55c204ac089c27c42110e40102a67cf18b675b1bb854aae0d30b801cf73e6a6761f40cdc2339ad04afffd62fadc815d41ef331f0dde3bb25968bc3f5c5f8adced7217d693e1a7671381abca90886e140f7099fb972e7d58ba7e57e77ff04a4aa81d203b1c8a10e73c0d34cea098c711cc844cc38cd08289f09a149248e27b58d3125fc16d8a6eab49df8c083736f1fa019cf0f5563cef0fedbe3186c3e4fa6cdc394b3b2bdc2818e32b7b5e84194f50c05953974006ae8174b8fea451f28fde7a56b2d0eafd77cadf9cdace8fa6c9d735eeebbd26d6bf882ba7a6f4492d6c09a0b78bb00bceced75583de489a609ecdcb44c64bf684c056beff7bfc8e92fc0a33a4e57999a24225d5e65191a16c5557a77bc24c40e9f6a7d08608ec89ae257c2bb78cbbbeb15deed24c59e0bd6554b74fc525d5e3ab12362c495816c01dce81a76b655a38574e66b5811186bef9255e65f601e73780b8246ce68577b3a5946d298313ad303e17c14604d8f9c673d4b84288599b04a40587d03197924c428b712336c678f1c6312c31d6d211f50fa6ee41d66a0eb14b2290a52d8e8ed841a6a119277d7250b52a027a4746bb087288fe4de610c0da5d679089cfc712c2f5de565b6b12b84f1c235cbba1c67e7b1f1904bd43ecf6d45cb84fffabe85095cdfa34e9b683c872f28527ede7cada3d6a469be91d4caafce424837640a9cec008874ce162e78edc5188ad83a67aa358559a51724c77886189e269cb40bb9af7bfff073057f53cda9c217d57a14ae9abcb23ea676f3816a5a1fea2c8da735477bd6a42489971f486bc98bea0b7fc7bab2cbbf5366ec25d7b5cdd7f452d7648e3af3b7253dc679ab68ad46a75be519a299659fdf20412d0850bc09aed231d93acdf6febf08917aa523dedacc6554607de0d4a87888e0152373d27da0ba7b0a0ffc04fd5e40b0735b0de059e75f72cf5caece0cf9716eb9374ecfe7e4cb12bd6ae71b005db150888f40f6ee43d89a01212199fbde0d9baa5c442fa5e182a4d6e97451aee3842f1c99c61e01f9c303c685aaf81a12f1f4f8379fcf90cf80e5ccebde2e1eaec6ca10af523817a5bd31d4de51df0fb1590fbd6139dac6012033ac8fe05cfe6f93b104daf714aa32f7f040bc831949a27469490b56cd0260658002a2a31fb5423a026e4c76d6d3facdda5b0fbecfff903311b37a203be7d582d1988a15c67d444e56898a0d76f39a768729361044af79ef9b604e925a12b5e2567541ce1b9d8f431ef0f81381159b59ea23f2fd6f03acd40b9aea38f4d732fc7096e39bf4f37ff79f600808cfeba84d7df17a91e2bbb7a74d17d26bbf2708108a444ab9f74b08ed684a5f8c8b70a67de8d671b2cb8e785a2b568d02e3f79dc5a0702cd78760dba7d1c514aca27b3a1e1aa2e2e6bf9e386dd85d9e994be8bca6206860ecb20589b98e13d4100f85d9905e0358c147c9a39166e034e07487c2a23cf99a324e67aa736f1c28c138885393751142cc78088385961d9fba213f7b742ca132b5a95e7dfa1fad3a7402fc5407efe415168513f30124682de3ac11b366f8a5eef509ee82a0137c03cc4034598f8faa9422c8e789f5675347feaf0224c938c09456a313076e69e392ffc5dc983b4db05590a2b79c9ddac2cf42d59f5b918f06191f8a44b03fd33c35401bca2f76686289520b0a3df318b2ab0ee36ed3fdba0fc555e6cbe963b5695e79d443a838766efb92925c0ffb528cb2fa8fd665ef8b517876c8dbb0bd7a9f9c97e2629598febd9ae4c4ef344dc01c21e36dcf22fd82f6345043c99b34a6f4b195ef2accfc955b821a073896645d5452ccaa67fbe7fa25b84e50130586b228f256c3c3eb47c81d4a3a8c2b2fb2f8d25e6d86085e249e394ec6e9e7ac113c9ddb329ea9d44d016ed90c46e83b0ffa0fedd893cc8916db6d6812de5552ca6b6e31e858e8ca3a4e97a5ba76880ba778d7ef1ebcfeca2b774cb538fd5934ca5ddd57bf1903611d5424e969dc91f92fc16977e2b467d28c1f59db4882b01f9fc1b476b8ec44eb71e80d8aebbcc3141808c01ca989ba72b1041fcffc52ef852bdcea1b71e92999bdb54e227c7b42c313c8ecadbb1d838f55ade53ffd6277c641ecdf8539b32ffaaf1b62f2a82a6e85b1ddb948030fa8abf21844aa9a5e5d3865ce43b2b33257c27335bfe8080c4d9114b9f8eed8af47baf5ae4dab1d96f4649dfd0e4ec73b5c03977081711025851e08bc0f28cd5767f593fcd6f341437d8c10c8ddc706ddd4aa6d9a0b4e1d121d112ab7eb2264303c037b07c14d4e748c9acab1df55538b29926974eb991117d15c6d9abd37a48ed177083f15ba742794ce12fb56c4da906a9a2aca07eb7fed6eb9698dd5fe0a159a4207996ca41011a71aace4a6c760e69d329c54f680fd3d6e0fbc84d289013960bf4c31213d397a1ba5292fde0efa6e41eec47a89b6eec75a9ec0285f2d84acd039d02bef247d1b197d79c37fb6a6e467dc7aa0279f2f277fcb0044e1c63b3a61c7a9bda995b9ab97ef92950c8989517c3ca006e6f73708bdd4377732bd6529ef6a3a434933949d5b9d49eaf650c45f8dec1befb79c1752204668a180b1b4ed5265beac6dff7a1b5edc315400b5c385326abcf38077ddc1e394e0eb9bedb88d6564223abcb128c1b9c6d176a534e9e5f1551e516df1553eaf1ec7c685c25ab6a272c3dfaf259a560c6bb73e8a43369f57491e491c72b97f0d888224cddf7331bea2d9486dbf9dc5c8233e9446632945be19c239df3b62ec4ffa606ce00800784003a05563d31e0eb05f92d719304b1dd948733f474da043582de0a2ce2945fbbc4f5fdc768c8b14aeb6c3116462712656a842e03820be4f3f55f4134b854e3b2fc97f40e57c73e5d7cc3065d1b2c3ef9f83c536fcd21cf760ff19ad0a4a77bd07ad79e99a450290638bfa4356f8d0c6a5b73dd40784575bd89d568a893673538ab3336b0717e382f84cf413221d5c11112067e4920bfc353d8de76585982fd7229254d50725189b081e4286c2075ddd9daf8b04fff59d9bfa09e4a014fcecdce0430d6b0e91bb3f0ec16d9a39869d487862feabdadf71e0227cf67434a9e8334c132e44e19ed1a9e8bd40c7125dbd5ff1091509e8a1eb1157b7761a3185321f94bd5f3563e2ae406ed35216686372a1530ac9cca66b73c3abba0738742ee8281b6a9af5ff77501175a7c82bcecf526d2b395068ae12424f3f441371395ae20d1e693057706f23933237329f9194bfd748dc9cf7878a82bacb99676207b98f61e93d64b50349f650317be0b75d5772ba1287bd0eeb7becd9dd9c9b77466fae3b0eb99c3daf3459d1645c1ee397c86e71f84ea2822eb74f281bf6e547cdf4681a30411a1bd0bc67d0f52ba40d349f7d6238a04e1114835473a0e03fb1a5cc48b6210bc5a05cef01aaa867bc0bde163b500543eab4044cbffa2d0df603f7028678d35690f053ac9fbf8e6363646ccacd6822a89497b96c0329b2b9d9cfe2915cc21141a9f5a3c6b0177ceb44ac68b779ef3eb38155ccb0385ba503f9a7df2bf7d3a9d209157fbf095e2c2151940220a7f6290d8441144b34450550a9d6fec29a4eeef7d630f9e1bbd6a9fb304aca8963fa22ef6667973794a80f2bfb6e657bb50cece62c9d31a8c0e8650a6ece4075f87105e30fa4d39d556f8812c722579c44c26143a87750c75e5e2fc9c284cf9ca48c760a3bdb9b9b837ef44162460957ef18db7dc85ef53898e043041f9e14931142e87e5c68e256eecbef48b83124ce7068c257ff370e2e46fd24045037886efd0761b489263ce596b5c6acbc20639628ab2356a9c5e301e254b837c6f52511cc97780308a8c6f111000db5608b41804de1f7d0f09a4a03bfd6c976a55267951578886d46bc5a6067e4eafe87441dac991494b536b7d20330edf927014417fcdf892319d078f879ea6b83ad7ed2f493a5942edda5d54821c77e36d27792e02b3952bf3e83bc02c5b17deb71fa35dbeaf6dc3a8040ddc772491d948bd491f0ccd5c6d731c9904646b1f49583018e6a7262cd3b16210bf22b7e23cdd04954322827bb8c7f98b112d63d9a68b89e4a0e776303c3bfe7ea7cdc216fc69fdd6c51e6c5540434d2e597b362a8f91d748438de018ba261661864dc92e35c1a7c990b5f7a56f2b36b76521d9868b0658b31c7b45283c14b776f3e79b259c3c530e93ef419881dfdeae494ee016d708a5c110893328decfab821ae3b2b22b03f8f66c523a44721cc5901bb53f043ce44727846e46fc3445c9d02ca362661574c21a5fb175394ade9c50a083bb72782889eb653556dced2f29a3017fecebe6da0176cb97bd4b10599c46d8349b317e30ff0fbbc22955dc0997e2a5956a393420903a6a972713b396fc512e3e3adc2e2bd0034a8e6bda6ed2de785a3ac39ede62bd675cb2ddbbdbdb2450509aff8618a3152348c52444f5774e248241761c91a0f896442e58a72d022d5ad52d09132d7f3829c67dc6c031db69de00af11c7d4ec465c7541bbdbbfba75367c314e0c30c637f47fdae4ab724a494ef60a314048b2799328f39286899e02edad19fdcc7d578aea5b1593429060cea920b650928f7f83e011c8d86e088be4cbdf0590fc3485123500ad15e25fae8ada18e97fff29ae2192125d666d57bf363d120e448073fb578386295494ce0243df90f7faafeef32eb4e3e41586b9af55526801b0ba2e069d031c57cb6bec08de0b9216f9c93440e1080f55d9d001fcc26f090de1db30cb204c384ccbe7277a0550d8a951d5c118ac59bb84e77dcafab7918b5c07c6cfbeb8460189523ddcc8691c9f57975535c24775710962e2a31e2bc6a4e489f3fe0cba290c709c1d6db275b538e4288ac3926538f81cfac95baf5b64d22b32364c2bf871fca3c1be7197ccd786c2f7661880666471914e0088d33d9a61d47df6717283b0bca097b34f2109b18d0c6b4f1a91166febf15753243dc082c024ee1c46b9bec6e1f75ddda8d397d5657cb297463521fcf41e241a4af32fe7e8e50d057d8781f162e576bf47ef40870a1de8f76ef0b16e88e958b20b6ce4e485cfc661151c0dfd493e636b5032f58e6422de7133e4960b664ae0553c72102b980fd7165edd9a822ee53c3ad6304abe98b530b4b565f4395f754ec6a5e88650faf0c6e6d3dd1a9774452b2f75341c4cc36978a88c370368c6f8809fc6a7f0bafd210f97dfdcccedeac8700212a90c51f917c98110651734c3875b3ddb1b23eaea5b4001971b6765445ad9ba107fc4ff444f7865ee6f43273e105987450f7ad45e1f17f6ff0fb96248b4060e445a3ff8215492c30f24838cc5ffa17ad97c6d9b350088faab70309f57bf841ced0854135153a4b72ef152a1dd0e5a64bc2127df06ffdc989224da5bebb398846e497139a5efefb13d6d61fd4578763301de56502724365a7163e6690c482738355c809be0d9b3197530fec4540c020a9fd3ca41c0a15e372320b216309c3b722761471bce66c79</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">该文章已加密, 请输入密码点击回车（Enter）查看.</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>web前端</category>
      </categories>
  </entry>
  <entry>
    <title>fiddler抓包工具</title>
    <url>/posts/654bf45c.html</url>
    <content><![CDATA[<p><img src="/posts/654bf45c/fiddler.jpg" alt="fiddler"><br><code>Fiddler</code>是一个通过代理的方式进行抓包工具，它能记录所有客户端和服务器的<code>http</code>和<code>https</code>请求，允许你监视，设置断点，甚至修改输入输出数据，它运行时会在本地建立一个代理服务，可以将网络传输发送与接受的数据包进行<code>截获</code>、<code>重发</code>、<code>编辑</code>、<code>转存</code>等操作，也可以用来<code>检测网络安全</code>。</p>
<span id="more"></span>
<!-- ![charles](charles.png) -->

<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><h4 id="window系统安装Fiddler（下面以window为例）"><a href="#window系统安装Fiddler（下面以window为例）" class="headerlink" title="window系统安装Fiddler（下面以window为例）"></a>window系统安装<code>Fiddler</code>（下面以window为例）</h4><p>下载地址： <a href="https://www.telerik.com/download/fiddler">https://www.telerik.com/download/fiddler</a>  （需要梯子）</p>
<p>网盘下载： <a href="https://pan.baidu.com/s/1AQ1IBhNxg8xywiTR2ow68Q">https://pan.baidu.com/s/1AQ1IBhNxg8xywiTR2ow68Q</a>  提取码: k2jm  （下载到本地的）</p>
<blockquote>
<p>注意：win8之前用<code>Fiidler for .NET2</code>，win8之后用<code>Fiddler for .NET4</code>比较好</p>
</blockquote>
<h4 id="Mac系统安装Charles"><a href="#Mac系统安装Charles" class="headerlink" title="Mac系统安装Charles"></a>Mac系统安装<code>Charles</code></h4><p>跟window差别不是很大，这里不细说了，可以参考<a href="https://www.jianshu.com/p/933d78091d90">Charles使用教程</a></p>
<h3 id="Fiddler简介"><a href="#Fiddler简介" class="headerlink" title="Fiddler简介"></a>Fiddler简介</h3><p>Fiddler是通过改写HTTP代理，让数据从它那通过，来监控并且截取到数据。当然Fiddler很屌，在打开它的那一瞬间，它就已经设置好了浏览器的代理了。当你关闭的时候，它又帮你把代理还原了</p>
<h4 id="Fiddler设置"><a href="#Fiddler设置" class="headerlink" title="Fiddler设置"></a>Fiddler设置</h4><p>Fiddler想要抓到数据包，要确保<code>Capture Traffic</code>是开启，在<code>File</code> –&gt; <code>Capture Traffic</code>。开启后再左下角会有显示，当然也可以直接点击左下角的图标来<code>关闭/开启</code>抓包功能。<br><img src="/posts/654bf45c/1.jpg" alt="抓包设置"></p>
<p>开启<code>Capture Traffic</code>后，Fiddler就开始工作了，抓取到的数据包就会显示在列表里面了</p>
<p><img src="/posts/654bf45c/3.png" alt="抓包展示"></p>
<p>标题表示的含义</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#</td>
<td align="left">抓取HTTP Request的顺序，从1开始，以此递增</td>
</tr>
<tr>
<td align="center">Result</td>
<td align="left">HTTP状态码</td>
</tr>
<tr>
<td align="center">Protocol</td>
<td align="left">请求使用的协议，如HTTP/HTTPS/FTP等</td>
</tr>
<tr>
<td align="center">Host</td>
<td align="left">请求地址的主机名</td>
</tr>
<tr>
<td align="center">URL</td>
<td align="left">请求资源的位置</td>
</tr>
<tr>
<td align="center">Body</td>
<td align="left">该请求的大小</td>
</tr>
<tr>
<td align="center">Caching</td>
<td align="left">请求的缓存过期时间或者缓存控制值</td>
</tr>
<tr>
<td align="center">Content-Type</td>
<td align="left">请求响应的类型</td>
</tr>
<tr>
<td align="center">Process</td>
<td align="left">发送此请求的进程：进程ID</td>
</tr>
<tr>
<td align="center">Comments</td>
<td align="left">允许用户为此回话添加备注</td>
</tr>
<tr>
<td align="center">Custom</td>
<td align="left">允许用户设置自定义值</td>
</tr>
</tbody></table>
<p>图标表示的含义</p>
<table>
<thead>
<tr>
<th align="center">图标</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="/posts/654bf45c/icon1.gif" alt="图标"></td>
<td align="left">请求已经发往服务器</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon2.gif" alt="图标"></td>
<td align="left">已从服务器下载响应结果</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon3.gif" alt="图标"></td>
<td align="left">请求从断点处暂停</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon4.gif" alt="图标"></td>
<td align="left">响应从断点处暂停</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon5.gif" alt="图标"></td>
<td align="left">请求使用 HTTP 的 HEAD 方法，即响应没有内容（Body）</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon6.gif" alt="图标"></td>
<td align="left">请求使用 HTTP 的 POST 方法</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon7.gif" alt="图标"></td>
<td align="left">请求使用 HTTP 的 CONNECT 方法，使用 HTTPS 协议建立连接隧道</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon8.gif" alt="图标"></td>
<td align="left">响应是 HTML 格式</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon9.gif" alt="图标"></td>
<td align="left">响应是一张图片</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon10.gif" alt="图标"></td>
<td align="left">响应是脚本格式</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon11.gif" alt="图标"></td>
<td align="left">响应是 CSS 格式</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon12.gif" alt="图标"></td>
<td align="left">响应是 XML 格式</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon13.gif" alt="图标"></td>
<td align="left">响应是 JSON 格式</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon14.gif" alt="图标"></td>
<td align="left">响应是一个音频文件</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon15.gif" alt="图标"></td>
<td align="left">响应是一个视频文件</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon16.gif" alt="图标"></td>
<td align="left">响应是一个 SilverLight</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon17.gif" alt="图标"></td>
<td align="left">响应是一个 FLASH</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon18.gif" alt="图标"></td>
<td align="left">响应是一个字体</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon19.gif" alt="图标"></td>
<td align="left">普通响应成功</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon20.gif" alt="图标"></td>
<td align="left">响应是 HTTP/300、301、302、303 或 307 重定向</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon21.gif" alt="图标"></td>
<td align="left">响应是 HTTP/304（无变更）：使用缓存文件</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon22.gif" alt="图标"></td>
<td align="left">响应需要客户端证书验证</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon23.gif" alt="图标"></td>
<td align="left">服务端错误</td>
</tr>
<tr>
<td align="center"><img src="/posts/654bf45c/icon24.gif" alt="图标"></td>
<td align="left">会话被客户端、Fiddler 或者服务端终止</td>
</tr>
</tbody></table>
<h4 id="Statistics-请求的性能数据分析"><a href="#Statistics-请求的性能数据分析" class="headerlink" title="Statistics 请求的性能数据分析"></a>Statistics 请求的性能数据分析</h4><p>随意点击一个请求，就可以看到<code>Statistics</code>关于HTTP请求的性能以及数据分析了<br><img src="/posts/654bf45c/4.png" alt="图标"> </p>
<h4 id="Inspectors-查看数据内容"><a href="#Inspectors-查看数据内容" class="headerlink" title="Inspectors 查看数据内容"></a>Inspectors 查看数据内容</h4><p><code>Inspectors</code>是用于查看会话的内容，上半部分是请求的内容，下半部分是响应的内容<br><img src="/posts/654bf45c/5.png" alt="图标"> </p>
<h4 id="AutoResponder-允许拦截指定规则的请求"><a href="#AutoResponder-允许拦截指定规则的请求" class="headerlink" title="AutoResponder 允许拦截指定规则的请求"></a>AutoResponder 允许拦截指定规则的请求</h4><p><code>AutoResponder</code>允许你拦截指定规则的请求，并<code>返回本地资源</code>或<code>Fiddler资源</code>，从而<code>代替服务器响应</code>。<br>看下图5步，我将<code>baidu</code>这个关键字与我电脑<code>F:\blog\source\_posts\fiddler\fiddler.jpg</code>这张图片绑定了，点击<code>Save</code>保存后勾选<code>Enable rules</code>，再访问<code>baidu</code>，就会被劫持。<br><img src="/posts/654bf45c/6.png" alt="图标"> </p>
<p>设置好匹配规则后，现在去请求，返回之前设置的访问图片的地址</p>
<p><img src="/posts/654bf45c/7.png" alt="图标"></p>
<h4 id="Composer-自定义请求发送服务器"><a href="#Composer-自定义请求发送服务器" class="headerlink" title="Composer 自定义请求发送服务器"></a>Composer 自定义请求发送服务器</h4><p><code>Composer</code>允许自定义请求发送到服务器，可以手动创建一个新的请求，也可以在会话表中，拖拽一个现有的请求<br><code>Parsed模式</code>下你只需要提供简单的URLS地址即可（如下图，也可以在RequestBody定制一些属性，如模拟浏览器User-Agent）<br><img src="/posts/654bf45c/8.png" alt="图标"></p>
<h4 id="Filters-请求过滤规则"><a href="#Filters-请求过滤规则" class="headerlink" title="Filters 请求过滤规则"></a>Filters 请求过滤规则</h4><p><code>Fiters</code>是过滤请求用的，左边的窗口不断的更新，当你想看你系统的请求的时候，你刷新一下浏览器，一大片不知道哪来请求，看着碍眼，它还一直刷新你的屏幕。这个时候通过过滤规则来过滤掉那些不想看到的请求。<br><img src="/posts/654bf45c/9.png" alt="图标"><br>勾选左上角的<code>Use Filters</code>开启过滤器，这里有两个最常用的过滤条件：<code>Zone</code>和<code>Host</code></p>
<ul>
<li>Zone 指定只显示<code>内网（Intranet）</code>或<code>互联网（Internet）</code>的内容<br><img src="/posts/654bf45c/10.png" alt="图标"></li>
<li>Host 指定显示<code>某个域名下</code>的会话：<br><img src="/posts/654bf45c/11.png" alt="图标"></li>
</ul>
<h4 id="Timeline-请求响应时间"><a href="#Timeline-请求响应时间" class="headerlink" title="Timeline 请求响应时间"></a>Timeline 请求响应时间</h4><p>在左侧会话窗口点击一个或多个（同时按下 Ctrl 键），Timeline 便会显示指定内容从服务端传输到客户端的时间：<br><img src="/posts/654bf45c/12.png" alt="图标"></p>
<h3 id="Fiddler设置解密HTTPS的网络数据"><a href="#Fiddler设置解密HTTPS的网络数据" class="headerlink" title="Fiddler设置解密HTTPS的网络数据"></a>Fiddler设置解密HTTPS的网络数据</h3><p>Fiddler可以通过伪造CA证书来欺骗浏览器和服务器。大概原理就是在浏览器面前Fiddler伪装成一个HTTPS服务器，而在真正的HTTPS服务器面前Fiddler伪装成浏览器，从而实现解密HTTPS数据包的目的。<br>解密HTTPS需要手动开启步骤：<code>Tools</code> –&gt; <code>Options</code> –&gt;  <code>HTTPS</code></p>
<p><img src="/posts/654bf45c/13.jpg" alt="图标"><br>点击<code>Tools</code> -&gt; 选择<code>Options</code>-&gt; 选择<code>HTTPS</code> -&gt; 勾选<code>Decrypt HTTPS Traffic</code>和<code>Ignore servercertificate errors</code>(首次点击会弹出是否信任fiddler证书和安全提示，直接点击yes就行)</p>
<p><img src="/posts/654bf45c/13.png" alt="图标"></p>
<p>点击OK</p>
<p><img src="/posts/654bf45c/14.png" alt="图标"></p>
<h3 id="Fiddler-抓取Iphone-Android数据包"><a href="#Fiddler-抓取Iphone-Android数据包" class="headerlink" title="Fiddler 抓取Iphone / Android数据包"></a>Fiddler 抓取Iphone / Android数据包</h3><p>Fiddler抓取移动端设备的数据包，其实很简单，先来说说移动设备怎么去访问网络，看了下面这张图：</p>
<p><img src="/posts/654bf45c/15.png" alt="图标"><br>想要抓取手机访问的数据，让手机和电脑在同一个局域网络下，打开<code>Fiddler</code>工具，点击菜单栏中的 <code>Tools</code> –&gt; <code>Options</code> -&gt; <code>选择Connections</code> -&gt; <code>设置代理端口是8888</code> -&gt; <code>勾选Allow remote computers to connect</code> -&gt; <code>点击OK</code><br><img src="/posts/654bf45c/16.png" alt="图标"></p>
<p>一定要重新启动fiddler，这时在 Fiddler 可以看到自己本机无线网卡的IP了（要是没有的话可以在<code>cmd</code>终端中<code>ipconfig</code>找到自己的网卡IP）<br><img src="/posts/654bf45c/17.png" alt="图标"></p>
<p>在手机端连接和PC相同的wifi，并且设置代理IP与端口（代理IP就是上图的IP，端口是Fiddler的代理端口8888）<br><img src="/posts/654bf45c/18.png" alt="图标"></p>
<p>访问网页输入<code>代理IP</code>和<code>端口</code>，点击<code>FiddlerRoot certificate</code>，下载<code>Fiddler的证书</code>,注意：苹果手机用<code>safari</code>打开<br><img src="/posts/654bf45c/19.png" alt="图标"></p>
<p>安装证书</p>
<p><img src="/posts/654bf45c/20.png" alt="图标"></p>
<p>安装完证书，用手机访问应用，就可以看到截取到的数据包了</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>抓包</tag>
        <tag>fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript核心原理</title>
    <url>/posts/2541eeff.html</url>
    <content><![CDATA[<h3 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>JavaScript 的数据类型有下图所示的 8 种：<br><img src="/posts/2541eeff/1.png" alt="8种类型"><br>前 7 种类型为基础类型，最后 1 种（Object）为引用类型，而引用数据类型（Object）又分为图上这几种常见的类型：<code>Array</code> - 数组对象、<code>RegExp</code> - 正则对象、<code>Date</code> - 日期对象、<code>Math</code> - 数学函数、<code>Function</code> - 函数对象。<br>各种 JavaScript 的数据类型最后都会在初始化之后放在不同的内存中，因此上面的数据类型大致可以分成两类来进行存储：</p>
<ul>
<li>基础类型存储在<code>栈内存</code>，被引用或拷贝时，会创建一个完全相等的变量；</li>
<li>引用类型存储在<code>堆内存</code>，存储的是地址，多个引用指向同一个地址，这里会涉及一个<code>“共享”</code>的概念。</li>
</ul>
<h4 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h4><h5 id="判断方法1：typeof"><a href="#判断方法1：typeof" class="headerlink" title="判断方法1：typeof"></a>判断方法1：typeof</h5><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">typeof <span class="number">1</span> <span class="regexp">//</span> <span class="string">&#x27;number&#x27;</span></span><br><span class="line"></span><br><span class="line">typeof <span class="string">&#x27;1&#x27;</span> <span class="regexp">//</span> <span class="string">&#x27;string&#x27;</span></span><br><span class="line"></span><br><span class="line">typeof undefined <span class="regexp">//</span> <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line"></span><br><span class="line">typeof true <span class="regexp">//</span> <span class="string">&#x27;boolean&#x27;</span></span><br><span class="line"></span><br><span class="line">typeof Symbol() <span class="regexp">//</span> <span class="string">&#x27;symbol&#x27;</span></span><br><span class="line"></span><br><span class="line">typeof null <span class="regexp">//</span> <span class="string">&#x27;object&#x27;</span></span><br><span class="line"></span><br><span class="line">typeof [] <span class="regexp">//</span> <span class="string">&#x27;object&#x27;</span></span><br><span class="line"></span><br><span class="line">typeof &#123;&#125; <span class="regexp">//</span> <span class="string">&#x27;object&#x27;</span></span><br><span class="line"></span><br><span class="line">typeof console <span class="regexp">//</span> <span class="string">&#x27;object&#x27;</span></span><br><span class="line"></span><br><span class="line">typeof console.log <span class="regexp">//</span> <span class="string">&#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>typeof</code>对于基本类型，除了 <code>null</code> 都可以显示正确的类型，虽然<code>null</code>是基本类型，但是会显示<code>object</code>，这是一个存在很久的Bug，因为在 JS 的最初版本中，使用的是 <code>32位系统</code>，为了性能考虑使用低位存储了变量的类型信息，<code>000</code>开头代表是对象，然而 <code>null</code> 表示为全零，所以将它错误的判断为 <code>object</code> 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</p>
<h5 id="判断方法2：instanceof"><a href="#判断方法2：instanceof" class="headerlink" title="判断方法2：instanceof"></a>判断方法2：instanceof</h5><p>我们<code>new</code>一个对象，那么这个新对象就是它原型链继承上面的对象了，通过<code>instanceof</code>我们能判断这个对象是否是之前那个构造函数生成的对象，这样就基本可以判断出这个新对象的数据类型。下面通过代码来了解一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Car</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> benz = <span class="keyword">new</span> <span class="title class_">Car</span>()</span><br><span class="line"></span><br><span class="line">benz <span class="keyword">instanceof</span> <span class="title class_">Car</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;Mercedes Benz&#x27;</span>)</span><br><span class="line"></span><br><span class="line">car <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Covid-19&#x27;</span></span><br><span class="line"></span><br><span class="line">str <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>那么如何实现一个<code>instanceof</code>的底层实现呢，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里先用typeof来判断基础数据类型，如果是，直接返回false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> left !== <span class="string">&#x27;object&#x27;</span> || left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getProtypeOf是Object对象自带的API，能够拿到参数的原型对象</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;                  <span class="comment">//循环往下寻找，直到找到相同的原型对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(proto === right.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//找到相同原型对象，返回true</span></span><br><span class="line"></span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeof</span>(proto);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 验证一下自己实现的myInstanceof是否OK</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceof</span>(<span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">123</span>), <span class="title class_">Number</span>));    <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceof</span>(<span class="number">123</span>, <span class="title class_">Number</span>));                <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>前面两种判断数据类型的方法它们之间有什么差异呢？我总结了下面两点：</p>
<ul>
<li><p>instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；</p>
</li>
<li><p>而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断。</p>
</li>
</ul>
<h5 id="判断方法3：Object-prototype-toString"><a href="#判断方法3：Object-prototype-toString" class="headerlink" title="判断方法3：Object.prototype.toString"></a>判断方法3：Object.prototype.toString</h5><p><code>toString()</code>是<code>Object</code>的原型方法，调用该方法，可以统一返回格式为<code>“[object Xxx]”</code>的字符串，其中 <code>Xxx</code> 就是对象的类型。对于 <code>Object</code> 对象，直接调用 <code>toString()</code> 就能返回 <code>[object Object]</code>；而对于其他对象，则需要通过 <code>call</code> 来调用，才能返回正确的类型信息。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">Object<span class="selector-class">.prototype</span><span class="selector-class">.toString</span>(&#123;&#125;)       <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line">Object<span class="selector-class">.prototype</span><span class="selector-class">.toString</span><span class="selector-class">.call</span>(&#123;&#125;)  <span class="comment">// 同上结果，加上call也ok</span></span><br><span class="line">Object<span class="selector-class">.prototype</span><span class="selector-class">.toString</span><span class="selector-class">.call</span>(<span class="number">1</span>)    <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line">Object<span class="selector-class">.prototype</span><span class="selector-class">.toString</span><span class="selector-class">.call</span>(<span class="string">&#x27;1&#x27;</span>)  <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line">Object<span class="selector-class">.prototype</span><span class="selector-class">.toString</span><span class="selector-class">.call</span>(true)  <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line">Object<span class="selector-class">.prototype</span><span class="selector-class">.toString</span><span class="selector-class">.call</span>(<span class="built_in">function</span>()&#123;&#125;)  <span class="comment">// &quot;[object Function]&quot;</span></span><br><span class="line">Object<span class="selector-class">.prototype</span><span class="selector-class">.toString</span><span class="selector-class">.call</span>(null)   <span class="comment">//&quot;[object Null]&quot;</span></span><br><span class="line">Object<span class="selector-class">.prototype</span><span class="selector-class">.toString</span><span class="selector-class">.call</span>(undefined) <span class="comment">//&quot;[object Undefined]&quot;</span></span><br><span class="line">Object<span class="selector-class">.prototype</span><span class="selector-class">.toString</span><span class="selector-class">.call</span>(/<span class="number">123</span>/g)    <span class="comment">//&quot;[object RegExp]&quot;</span></span><br><span class="line">Object<span class="selector-class">.prototype</span><span class="selector-class">.toString</span><span class="selector-class">.call</span>(new <span class="built_in">Date</span>()) <span class="comment">//&quot;[object Date]&quot;</span></span><br><span class="line">Object<span class="selector-class">.prototype</span><span class="selector-class">.toString</span><span class="selector-class">.call</span>(<span class="selector-attr">[]</span>)       <span class="comment">//&quot;[object Array]&quot;</span></span><br><span class="line">Object<span class="selector-class">.prototype</span><span class="selector-class">.toString</span><span class="selector-class">.call</span>(document)  <span class="comment">//&quot;[object HTMLDocument]&quot;</span></span><br><span class="line">Object<span class="selector-class">.prototype</span><span class="selector-class">.toString</span><span class="selector-class">.call</span>(window)   <span class="comment">//&quot;[object Window]&quot;</span></span><br></pre></td></tr></table></figure>
<p>下面来实现一个全局通用的数据类型判断方法，代码如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> getType(obj)&#123;</span><br><span class="line">    let type  = typeof obj;</span><br><span class="line">    <span class="keyword">if</span> (type !== <span class="string">&quot;object&quot;</span>) &#123;    <span class="regexp">//</span> 先进行typeof判断，如果是基础数据类型，直接返回</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="regexp">//</span> 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span><br><span class="line">    return Object.prototype.toString.call(obj).replace(<span class="regexp">/^\[object (\S+)\]$/</span>, <span class="string">&#x27;$1&#x27;</span>);  <span class="regexp">//</span> 注意正则中间有个空格</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/* 代码验证，需要注意大小写，哪些是typeof判断，哪些是toString判断？思考下 */</span></span><br><span class="line">getType([])     <span class="regexp">//</span> <span class="string">&quot;Array&quot;</span> typeof []是object，因此toString返回</span><br><span class="line">getType(<span class="string">&#x27;123&#x27;</span>)  <span class="regexp">//</span> <span class="string">&quot;string&quot;</span> typeof 直接返回</span><br><span class="line">getType(window) <span class="regexp">//</span> <span class="string">&quot;Window&quot;</span> toString返回</span><br><span class="line">getType(null)   <span class="regexp">//</span> <span class="string">&quot;Null&quot;</span>首字母大写，typeof null是object，需toString来判断</span><br><span class="line">getType(undefined)   <span class="regexp">//</span> <span class="string">&quot;undefined&quot;</span> typeof 直接返回</span><br><span class="line">getType()            <span class="regexp">//</span> <span class="string">&quot;undefined&quot;</span> typeof 直接返回</span><br><span class="line">getType(<span class="keyword">function</span>()&#123;&#125;) <span class="regexp">//</span> <span class="string">&quot;function&quot;</span> typeof能判断，因此首字母小写</span><br><span class="line">getType(<span class="regexp">/123/g</span>)      <span class="regexp">//</span><span class="string">&quot;RegExp&quot;</span> toString返回</span><br></pre></td></tr></table></figure>
<h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>创建一个新的对象，来接收你要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象；但如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，肯定会影响到另一个对象。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">let <span class="selector-tag">a</span> = &#123;</span><br><span class="line">    age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">let <span class="selector-tag">b</span> = <span class="selector-tag">a</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.age</span> = <span class="number">2</span></span><br><span class="line">console<span class="selector-class">.log</span>(<span class="selector-tag">b</span>.age) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上述例子看出，给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变，如果不想要改变，可以用浅拷贝的方式，下面就是浅拷贝的几种方法：</p>
<h5 id="方法1：object-assign"><a href="#方法1：object-assign" class="headerlink" title="方法1：object.assign"></a>方法1：<code>object.assign</code></h5><p><code>object.assign</code>是 ES6 中 object 的一个方法，该方法可以用于 JS 对象的合并等多个用途，该方法有两个参数：<br>参数1：<code>拷贝的目标对象</code>，<br>参数2：<code>拷贝的来源对象（也可以是多个来源）</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;,a)</span><br><span class="line">a.<span class="property">age</span> = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">age</span>)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>object.assign</code> 方法有几点需要注意：</p>
<ul>
<li>它不会拷贝对象的继承属性；</li>
<li>它不会拷贝对象的不可枚举的属性；</li>
<li>可以拷贝 Symbol 类型的属性。</li>
</ul>
<h5 id="方法2：-扩展运算符方式"><a href="#方法2：-扩展运算符方式" class="headerlink" title="方法2：...扩展运算符方式"></a>方法2：<code>...</code>扩展运算符方式</h5><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">let <span class="selector-tag">a</span> = &#123;</span><br><span class="line">    age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">let <span class="selector-tag">b</span> = &#123;...a&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.age</span> = <span class="number">2</span></span><br><span class="line">console<span class="selector-class">.log</span>(<span class="selector-tag">b</span>.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><code>扩展运算符</code>和<code>object.assign</code>有同样的缺陷，也就是实现的浅拷贝的功能差不多，但是如果属性都是<code>基本类型</code>的值，使用扩展运算符进行浅拷贝会更加方便。</p>
<h5 id="方法3：concat拷贝数组"><a href="#方法3：concat拷贝数组" class="headerlink" title="方法3：concat拷贝数组"></a>方法3：<code>concat</code>拷贝数组</h5><p>语法：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">array</span>Object.concat(<span class="built_in">array</span>X,<span class="built_in">array</span>X,......,<span class="built_in">array</span>X)</span><br></pre></td></tr></table></figure>
<p>concat() 方法用于连接两个或多个数组，该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。注意：concat只能用于数组的浅拷贝，使用场景比较局限。代码如下所示。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">let arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">let <span class="keyword">new</span><span class="type">Arr</span> = arr.concat();</span><br><span class="line"><span class="keyword">new</span><span class="type">Arr</span>[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line">console.log(arr);  <span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line">console.log(<span class="keyword">new</span><span class="type">Arr</span>); <span class="comment">// [ 1, 100, 3 ]</span></span><br></pre></td></tr></table></figure>
<h5 id="方法4：slice拷贝数组"><a href="#方法4：slice拷贝数组" class="headerlink" title="方法4：slice拷贝数组"></a>方法4：<code>slice</code>拷贝数组</h5><p>语法：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">arrayObject.<span class="keyword">slice</span>(<span class="keyword">begin</span>, <span class="keyword">end</span>);</span><br></pre></td></tr></table></figure>
<p>slice()方法可从已有的数组中返回选定的元素，该方法并不会修改数组，而是返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素，下面是实现浅拷贝的代码示例：</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="keyword">val</span><span class="operator">:</span> 4&#125;];</span><br><span class="line"><span class="keyword">let</span> newArr <span class="operator">=</span> arr.slice();</span><br><span class="line">newArr[<span class="number">2</span>].<span class="keyword">val</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">console.log(arr);  <span class="comment">//[ 1, 2, &#123; val: 1000 &#125; ]</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看出，浅拷贝只能拷贝一层对象。如果存在对象的嵌套，那么浅拷贝将无能为力，为了解决这个问题，这个时候就可以采用深拷贝，它能解决多层对象嵌套问题，彻底实现拷贝。</p>
<h5 id="手工实现浅拷贝"><a href="#手工实现浅拷贝" class="headerlink" title="手工实现浅拷贝"></a>手工实现浅拷贝</h5><p>实现思路：</p>
<ul>
<li>对基础类型做一个最基本的一个拷贝；</li>
<li>对引用类型开辟一个新的存储，并且拷贝一层对象属性。</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowClone = (<span class="keyword">target</span>) =&gt; &#123;</span><br><span class="line">   <span class="comment">// 类型判断，基本类型直接返回，针对引用类型的对象进行 for 循环遍历对象属性赋值给目标对象的属性</span></span><br><span class="line">  <span class="keyword">if</span> (typeof <span class="keyword">target</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">target</span> !== <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cloneTarget = Array.isArray(<span class="keyword">target</span>) ? []: &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (let prop in <span class="keyword">target</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">target</span>.hasOwnProperty(prop)) &#123;</span><br><span class="line">          cloneTarget[prop] = <span class="keyword">target</span>[prop];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">target</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>hasOwnProperty()</code>方法用来检测一个属性是否是对象的自有属性，而不是从原型链继承的。如果该属性是自有属性，那么返回<code>true</code>，否则返回 <code>false</code>。换句话说，<code>hasOwnProperty()</code>方法不会检测对象的原型链，只会检测当前对象本身，只有当前对象本身存在该属性时才返回<code>true</code>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>(prop)) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>将一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不会改变原对象，二者实现真正的分离。</p>
<h5 id="方法1：JSON-stringfy"><a href="#方法1：JSON-stringfy" class="headerlink" title="方法1：JSON.stringfy"></a>方法1：<code>JSON.stringfy</code></h5><p>JSON.stringify()是目前开发过程中最简单的深拷贝方法，其实就是把一个对象序列化成为JSON的字符串，并将对象里面的内容转换成字符串，最后再用<code>JSON.parse()</code>的方法将<code>JSON字符串</code>生成一个新的对象。示例代码如下所示:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">let</span> obj1 = &#123; a:<span class="number">1</span>, b:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] &#125;</span><br><span class="line"><span class="attribute">let</span> str = JSON.stringify(obj1)；</span><br><span class="line"><span class="attribute">let</span> obj2 = JSON.parse(str)；</span><br><span class="line"><span class="attribute">console</span>.log(obj2);   //&#123;a:<span class="number">1</span>,b:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125; </span><br><span class="line"><span class="attribute">obj1</span>.a = <span class="number">2</span>；</span><br><span class="line"><span class="attribute">obj1</span>.b.push(<span class="number">4</span>);</span><br><span class="line"><span class="attribute">console</span>.log(obj1);   //&#123;a:<span class="number">2</span>,b:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&#125;</span><br><span class="line"><span class="attribute">console</span>.log(obj2);   //&#123;a:<span class="number">1</span>,b:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>该方法也是有局限性的：</p>
<ul>
<li>拷贝的对象的值中如果有<code>函数</code>、<code>undefined</code>、<code>symbol</code>这几种类型，经过<code>JSON.stringify序列化</code>之后的字符串中这个<code>键值对会消失</code>；</li>
<li>拷贝 Date 引用类型会变成字符串；</li>
<li>无法拷贝不可枚举的属性；</li>
<li>无法拷贝对象的原型链；</li>
<li>拷贝 RegExp 引用类型会变成空对象；</li>
<li>对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null；</li>
<li>无法拷贝对象的循环引用</li>
</ul>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 针对上面说法示例：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert(<span class="number">1</span>) &#125;; </span><br><span class="line">  <span class="keyword">this</span>.obj = &#123;<span class="attribute">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">this</span>.und = <span class="literal">undefined</span>; </span><br><span class="line">  <span class="keyword">this</span>.reg = <span class="regexp">/123/</span>; </span><br><span class="line">  <span class="keyword">this</span>.date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>); </span><br><span class="line">  <span class="keyword">this</span>.NaN = <span class="literal">NaN</span>;</span><br><span class="line">  <span class="keyword">this</span>.infinity = <span class="literal">Infinity</span>;</span><br><span class="line">  <span class="keyword">this</span>.sym = <span class="built_in">Symbol</span>(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> Obj();</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj1,<span class="string">&#x27;innumerable&#x27;</span>,&#123; </span><br><span class="line">  <span class="attribute">enumerable</span>:<span class="attribute">false,</span></span><br><span class="line"><span class="attribute">  value</span>:<span class="string">&#x27;innumerable&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;obj1&#x27;</span>,obj1);</span><br><span class="line"><span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(obj1);</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">JSON</span>.parse(str);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;obj2&#x27;</span>,obj2);</span><br></pre></td></tr></table></figure>
<p>以上代码的打印结果：<br><img src="/posts/2541eeff/2.png" alt="打印结果"><br>使用 JSON.stringify 方法实现深拷贝对象，虽然到目前为止还有很多无法实现的功能，但是这种方法足以满足日常的开发需求，并且是最简单和快捷的。而对于其他的也要实现深拷贝的，比较麻烦的属性对应的数据类型，JSON.stringify 暂时还是无法满足的，那么就需要下面的几种方法了。</p>
<h5 id="方法2：基础版（手写递归实现）"><a href="#方法2：基础版（手写递归实现）" class="headerlink" title="方法2：基础版（手写递归实现）"></a>方法2：基础版（手写递归实现）</h5><p>下面是一个实现 deepClone 函数封装的例子，通过 for in 遍历传入参数的属性值，如果值是引用类型则再次递归调用该函数，如果是基础数据类型就直接复制，代码如下所示。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  a:&#123;</span><br><span class="line">    b:<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> deep<span class="constructor">Clone(<span class="params">obj</span>)</span> &#123; </span><br><span class="line">  <span class="keyword">let</span> cloneObj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;                 <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">if</span>(typeof obj<span class="literal">[<span class="identifier">key</span>]</span> ===&#x27;<span class="keyword">object</span>&#x27;) &#123; </span><br><span class="line">      cloneObj<span class="literal">[<span class="identifier">key</span>]</span> = deep<span class="constructor">Clone(<span class="params">obj</span>[<span class="params">key</span>])</span>  <span class="comment">//是对象就再次调用该函数递归</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cloneObj<span class="literal">[<span class="identifier">key</span>]</span> = obj<span class="literal">[<span class="identifier">key</span>]</span>  <span class="comment">//基本类型的话直接复制值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cloneObj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = deep<span class="constructor">Clone(<span class="params">obj1</span>)</span>;</span><br><span class="line">obj1.a.b = <span class="number">2</span>;</span><br><span class="line">console.log(obj2);   <span class="comment">//  &#123;a:&#123;b:1&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>虽然利用递归能实现一个深拷贝，但是同上面的 JSON.stringfy 一样，还是有一些问题没有完全解决，例如：</p>
<ul>
<li>这个深拷贝函数并不能复制不可枚举的属性以及 Symbol 类型；</li>
<li>这种方法只是针对普通的引用类型的值做递归复制，而对于 Array、Date、RegExp、Error、Function 这样的引用类型并不能正确地拷贝；</li>
<li>对象的属性里面成环，即循环引用没有解决。</li>
</ul>
<p>这种基础版本的写法也比较简单，可以应对大部分的应用情况。</p>
<h5 id="方法3：改进版（改进后递归实现）"><a href="#方法3：改进版（改进后递归实现）" class="headerlink" title="方法3：改进版（改进后递归实现）"></a>方法3：改进版（改进后递归实现）</h5><p>针对上面几个待解决问题，我先通过四点相关的理论告诉你分别应该怎么做。</p>
<ul>
<li>针对能够遍历对象的不可枚举属性以及 Symbol 类型，我们可以使用 Reflect.ownKeys 方法；</li>
<li>当参数为 Date、RegExp 类型，则直接生成一个新的实例返回；</li>
<li>利用 Object 的 getOwnPropertyDescriptors 方法可以获得对象的所有属性，以及对应的特性，顺便结合 Object 的 create 方法创建一个新对象，并继承传入原对象的原型链；</li>
<li>利用 WeakMap 类型作为 Hash 表，因为 WeakMap 是弱引用类型，可以有效防止内存泄漏（你可以关注一下 Map 和 weakMap 的关键区别，这里要用 weakMap），作为检测循环引用很有帮助，如果存在循环，则引用直接返回 WeakMap 存储的值。</li>
</ul>
<p>那么针对上面这几个问题，我们来看下改进后的递归实现的深拷贝代码应该是什么样子的，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isComplexDataType</span> = obj =&gt; (<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> obj === <span class="string">&#x27;function&#x27;</span>) &amp;&amp; (obj !== <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="keyword">function</span> (<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">constructor</span> === <span class="title class_">Date</span>) </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj)       <span class="comment">// 日期对象直接返回一个新的日期对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">constructor</span> === <span class="title class_">RegExp</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj)     <span class="comment">//正则对象直接返回一个新的正则对象</span></span><br><span class="line">  <span class="comment">//如果循环引用了就用 weakMap 来解决</span></span><br><span class="line">  <span class="keyword">if</span> (hash.<span class="title function_">has</span>(obj)) <span class="keyword">return</span> hash.<span class="title function_">get</span>(obj)</span><br><span class="line">  <span class="keyword">let</span> allDesc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line">  <span class="comment">//遍历传入参数所有键的特性</span></span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj), allDesc)</span><br><span class="line">  <span class="comment">//继承原型链</span></span><br><span class="line">  hash.<span class="title function_">set</span>(obj, cloneObj)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj)) &#123; </span><br><span class="line">    cloneObj[key] = (<span class="title function_">isComplexDataType</span>(obj[key]) &amp;&amp; <span class="keyword">typeof</span> obj[key] !== <span class="string">&#x27;function&#x27;</span>) ? <span class="title function_">deepClone</span>(obj[key], hash) : obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面是验证代码</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">str</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">boolean</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">unf</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">nul</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;我是一个对象&#x27;</span>, <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  <span class="attr">arr</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  <span class="attr">func</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是一个函数&#x27;</span>) &#125;,</span><br><span class="line">  <span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0</span>),</span><br><span class="line">  <span class="attr">reg</span>: <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;/我是一个正则/ig&#x27;</span>),</span><br><span class="line">  [<span class="title class_">Symbol</span>(<span class="string">&#x27;1&#x27;</span>)]: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;innumerable&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">&#x27;不可枚举属性&#x27;</span> &#125;</span><br><span class="line">);</span><br><span class="line">obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj, <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj))</span><br><span class="line">obj.<span class="property">loop</span> = obj    <span class="comment">// 设置loop成循环引用的属性</span></span><br><span class="line"><span class="keyword">let</span> cloneObj = <span class="title function_">deepClone</span>(obj)</span><br><span class="line">cloneObj.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="number">4</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj&#x27;</span>, obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;cloneObj&#x27;</span>, cloneObj)</span><br></pre></td></tr></table></figure>
<p>我们看一下结果，cloneObj 在 obj 的基础上进行了一次深拷贝，cloneObj 里的 arr 数组进行了修改，并未影响到 obj.arr 的变化，如下图所示。<br><img src="/posts/2541eeff/3.png" alt="展示结果"><br>从这张截图的结果可以看出，改进版的 deepClone 函数已经对基础版的那几个问题进行了改进，也验证了我上面提到的那四点理论。</p>
<h3 id="JS常见的6种继承方式"><a href="#JS常见的6种继承方式" class="headerlink" title="JS常见的6种继承方式"></a>JS常见的6种继承方式</h3><p>在学习继承之前，先了解原型链，便于更好的理解<br><img src="/posts/2541eeff/4.png" alt="原型链"></p>
<h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型链继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> ()&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;zs&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">20</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span>= <span class="string">&#x27;child2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Child</span>())</span><br></pre></td></tr></table></figure>
<p>原型链继承方式也是有缺点的，如下代码：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Child();</span><br><span class="line">s1.play.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(s1.play, s2.play); <span class="comment">// [1,2,3,4]  [1,2,3,4]</span></span><br></pre></td></tr></table></figure>
<p>因为两个实例使用的是同一个原型对象。它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化</p>
<h4 id="构造函数继承（借助-call）"><a href="#构造函数继承（借助-call）" class="headerlink" title="构造函数继承（借助 call）"></a>构造函数继承（借助 call）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;zs&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span>= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getAge</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`20岁`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line">s.<span class="property">type</span>.<span class="title function_">push</span>(<span class="number">4</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s,s2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">getName</span>())  <span class="comment">// 报错 s.getName is not a function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">getAge</span>())  <span class="comment">// 20岁</span></span><br></pre></td></tr></table></figure>
<p>从上面的结果就可以看到构造函数实现继承的优缺点，它使父类的引用属性不会被共享，优化了第一种继承方式的弊端；但是随之而来的缺点也比较明显——<code>只能</code>继承父类的实例属性和方法，<code>不能</code>继承原型属性或者方法</p>
<h4 id="组合继承（前两种组合）"><a href="#组合继承（前两种组合）" class="headerlink" title="组合继承（前两种组合）"></a>组合继承（前两种组合）</h4><p>这种方式结合了前两种继承方式的优缺点，结合起来的继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 第二次调用 Person()</span></span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&quot;child&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 第一次调用 Person()</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="comment">// 手动挂上构造器，指向自己的构造函数</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line">s.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="number">4</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">arr</span>,s2.<span class="property">arr</span>) <span class="comment">// [1, 2, 3, 4]   [1, 2, 3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">getName</span>());  <span class="comment">// zs</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2.<span class="title function_">getName</span>()); <span class="comment">// zs</span></span><br></pre></td></tr></table></figure>
<p>从<code>组合继承</code>打印的结果可以看出，上面<code>原型链继承</code>和<code>构造函数继承</code>的问题都得以解决，但是有个新的问题是，<code>Person</code>执行了两次，<code>第一次</code>改变<code>Child</code>的<code>prototype</code>的时候，<code>第二次</code>是通过<code>call</code>调用<code>Person</code>的时候，<code>Person</code>多构造一次就多进行一次性能开销，这是一个缺点。</p>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>通过ES5 里面的 <code>Object.create</code>方法，这个方法接收两个参数：<code>参数1</code>：用作新对象原型的对象、<code>参数2</code>：为新对象定义额外属性的对象（可选参数）</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">let parent4 = &#123;</span><br><span class="line">  <span class="type">name</span>: &quot;parent4&quot;,</span><br><span class="line">  friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],</span><br><span class="line">  getName: <span class="keyword">function</span> () &#123;</span><br><span class="line">      <span class="keyword">return</span> this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let p = <span class="keyword">Object</span>.<span class="keyword">create</span>(parent4);</span><br><span class="line">p.name = &quot;tom&quot;;</span><br><span class="line">p.friends.push(&quot;jerry&quot;);</span><br><span class="line"></span><br><span class="line">let p2 = <span class="keyword">Object</span>.<span class="keyword">create</span>(parent4);</span><br><span class="line">p2.friends.push(&quot;lucy&quot;);</span><br><span class="line"></span><br><span class="line">console.log(p.name);  // tom</span><br><span class="line">console.log(p.name === p.getName());  // <span class="keyword">true</span></span><br><span class="line">console.log(p.name);  // parent4</span><br><span class="line">console.log(p.friends); //  [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;, &quot;jerry&quot;, &quot;lucy&quot;]</span><br><span class="line">console.log(p2.friends); //  [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;, &quot;jerry&quot;, &quot;lucy&quot;] </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>后两个输出结果是一样的，可以联想到上面的浅拷贝的知识点，关于引用数据类型<code>“共享”</code>的问题，其实<code>Object.create</code>方法是可以为一些对象实现浅拷贝的，关于这种继承方式的缺点也很明显，多个实例的引用类型属性指向相同的内存，存在篡改的可能。</p>
<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>上面使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力再进行增强，添加一些方法，这样的继承方式就叫作<code>寄生式继承</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> parent5 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;parent5&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&quot;p1&quot;</span>, <span class="string">&quot;p2&quot;</span>, <span class="string">&quot;p3&quot;</span>],</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">original</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(original);</span><br><span class="line">    clone.<span class="property">getFriends</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">friends</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="title function_">clone</span>(parent5);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="title function_">getName</span>());    <span class="comment">// parent5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="title function_">getFriends</span>()); <span class="comment">// [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;]</span></span><br></pre></td></tr></table></figure>
<p>通过上面这段代码可以看到 p 是通过寄生式继承生成的实例，它不仅仅有 getName 的方法，而且可以看到它最后也拥有了 getFriends 的方法，从最后的输出结果中可以看到，p 通过clone的方法，增加了 getFriends 的方法，从而使 p 这个普通对象在继承过程中又增加了一个方法，这样的继承方式就是寄生式继承。我在上面第三种组合继承方式中提到了一些弊端，即两次调用父类的构造函数造成浪费，下面要介绍的寄生组合继承就可以解决这个问题。</p>
<h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>结合上面<code>寄生式继承</code>中提及的继承方式，解决普通对象的继承问题的<code>Object.create</code>方法，我们在前面这几种继承方式的优缺点基础上进行改造，得出了寄生组合式的继承方式，<code>这也是所有继承方式里面相对最优的继承方式</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span> (parent, child) &#123;</span><br><span class="line">  <span class="comment">// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span></span><br><span class="line">  child.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  child.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent6</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent6&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent6</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child6</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Parent6</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = <span class="string">&#x27;child5&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">clone</span>(<span class="title class_">Parent6</span>, <span class="title class_">Child6</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child6</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getFriends</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">friends</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person6 = <span class="keyword">new</span> <span class="title class_">Child6</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person6);  <span class="comment">// &#123;friends: &quot;child5&quot;,name: &quot;parent6&quot;,play: (3) [1, 2, 3]&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person6.<span class="title function_">getName</span>());  <span class="comment">// parent6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person6.<span class="title function_">getFriends</span>()); <span class="comment">// child5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过这段代码可以看出来，这种寄生组合式继承方式，基本可以解决前几种继承方式的缺点，较好地实现了继承想要的结果，同时也减少了构造次数，减少了性能的开销，可以看到 person6 打印出来的结果，属性都得到了继承，方法也没问题，可以输出预期的结果。<br>整体看下来，这六种继承方式中，寄生组合式继承是这六种里面最优的继承方式。另外，ES6 还提供了继承的关键字 extends，我们再看下 extends 的底层实现继承的逻辑。</p>
<h4 id="ES6的extends继承"><a href="#ES6的extends继承" class="headerlink" title="ES6的extends继承"></a>ES6的extends继承</h4><p>利用 ES6 里的 extends 的语法糖，使用关键词很容易直接实现 JavaScript 的继承，但是如果想深入了解 extends 语法糖是怎么实现的，就得深入研究 extends 的底层逻辑，我们先看下用利用 extends 如何直接实现继承。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 原型方法</span></span><br><span class="line">  <span class="comment">// 即 Person.prototype.getName = function() &#123; &#125;</span></span><br><span class="line">  <span class="comment">// 下面可以简写为 getName() &#123;...&#125;</span></span><br><span class="line">  getName = function () &#123;</span><br><span class="line">    console.log(&#x27;<span class="type">Person</span>:&#x27;, <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gamer</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  constructor(name, age) &#123;</span><br><span class="line">    <span class="comment">// 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const asuna = <span class="keyword">new</span> <span class="type">Gamer</span>(&#x27;<span class="type">Asuna</span>&#x27;, <span class="number">20</span>)</span><br><span class="line">asuna.getName() <span class="comment">// 成功访问到父类的方法</span></span><br></pre></td></tr></table></figure>
<p>因为浏览器的兼容性问题，如果遇到不支持 ES6 的浏览器，那么就得利用 babel 这个编译工具，将 ES6 的代码编译成 ES5，让一些不支持新语法的浏览器也能运行。<br>那么最后 extends 编译成了什么样子呢？我们看一下转译之后的代码片段</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_possibleConstructorReturn</span> (<span class="params">self, call</span>) </span>&#123; </span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		<span class="keyword">return</span> call &amp;&amp; (<span class="keyword">typeof</span> call === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> call === <span class="string">&#x27;function&#x27;</span>) ? <span class="attribute">call</span> : self; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span> (<span class="params">subClass, superClass</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 这里可以看到</span></span><br><span class="line">	subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123; </span><br><span class="line">		<span class="attribute">constructor</span>: &#123; </span><br><span class="line">			<span class="attribute">value</span>: subClass, </span><br><span class="line">			<span class="attribute">enumerable</span>: <span class="literal">false</span>, </span><br><span class="line">			<span class="attribute">writable</span>: <span class="literal">true</span>, </span><br><span class="line">			<span class="attribute">configurable</span>: <span class="literal">true</span> </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;); </span><br><span class="line">	<span class="keyword">if</span> (superClass) <span class="built_in">Object</span>.setPrototypeOf ? <span class="built_in">Object</span>.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 验证是否是 Parent 构造出来的 this</span></span><br><span class="line">	_classCallCheck(<span class="keyword">this</span>, Parent);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Child = (<span class="function"><span class="keyword">function</span> (<span class="params">_Parent</span>) </span>&#123;</span><br><span class="line">	_inherits(Child, _Parent);</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		_classCallCheck(<span class="keyword">this</span>, Child);</span><br><span class="line">		<span class="keyword">return</span> _possibleConstructorReturn(<span class="keyword">this</span>, (Child.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(Child)).apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> Child;</span><br><span class="line">&#125;(Parent));</span><br></pre></td></tr></table></figure>
<p>从上面编译完成的源码中可以看到，它采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式。</p>
<h3 id="实现new、apply、call、bind的底层逻辑"><a href="#实现new、apply、call、bind的底层逻辑" class="headerlink" title="实现new、apply、call、bind的底层逻辑"></a>实现new、apply、call、bind的底层逻辑</h3><h4 id="new原理介绍"><a href="#new原理介绍" class="headerlink" title="new原理介绍"></a>new原理介绍</h4><p>new 关键词的主要作用就是执行一个构造函数、返回一个实例对象，在 new 的过程中，根据构造函数的情况，来确定是否可以接受参数的传递</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">   this.name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(p.name)  <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>
<p>大致分为以下几个步骤:</p>
<ul>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋给新对象（this 指向新对象）；</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>返回新对象。</li>
</ul>
<p>下面对构造函数稍微改动一下，直接return看下会发生什么变化</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">   this.name = <span class="string">&#x27;Jack&#x27;</span>; </span><br><span class="line">   <span class="keyword">return</span> &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(p)  <span class="comment">// &#123;age: 18&#125;</span></span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(p.name) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(p.age) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>
<p>当构造函数最后 return 出来的是一个和 this 无关的对象时，new 命令会直接返回这个新对象，而不是通过 new 执行步骤生成的 this 对象。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">   this.name = <span class="string">&#x27;Jack&#x27;</span>; </span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;tom&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(p)  <span class="comment">// &#123;name: &#x27;Jack&#x27;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(p.name) <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>
<p>当构造函数中 return 的不是一个对象时，那么它还是会根据 new 关键词的执行逻辑，生成一个新的对象（绑定了最新 this），最后返回出来。</p>
<blockquote>
<p>总结：new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象。</p>
</blockquote>
<h4 id="apply-amp-call-amp-bind-原理介绍"><a href="#apply-amp-call-amp-bind-原理介绍" class="headerlink" title="apply &amp; call &amp; bind 原理介绍"></a>apply &amp; call &amp; bind 原理介绍</h4><p>call、apply 和 bind 是挂在 Function 对象上的三个方法，调用这三个方法的必须是一个函数。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 基本语法：</span><br><span class="line"><span class="keyword">func</span>.call(thisArg, param1, param2, ...)</span><br><span class="line"><span class="keyword">func</span>.apply(thisArg, [param1,param2,...])</span><br><span class="line"><span class="keyword">func</span>.bind(thisArg, param1, param2, ...)</span><br></pre></td></tr></table></figure>
<p>其中 func 是要调用的函数，thisArg 一般为 this 所指向的对象，后面的 param1、2 为函数 func 的多个参数，如果 func 不需要参数，则后面的 param1、2 可以不写。<br>这三个方法共有的、比较明显的作用就是，都可以改变函数 func 的 this 指向。call 和 apply 的区别在于，传参的写法不同：apply 的第 2 个参数为数组； call 则是从第 2 个至第 N 个都是给 func 的传参；而 bind 和这两个（call、apply）又不同，bind 虽然改变了 func 的 this 指向，但不是马上执行，而这两个（call、apply）是在改变了函数的 this 指向之后立马执行。</p>
<p>下面例子分析：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> msg + this.name;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">let b = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lily&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(a.getName(<span class="string">&#x27;hello~&#x27;</span>));  <span class="comment">// hello~jack</span></span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(a.getName.call(b, <span class="string">&#x27;hi~&#x27;</span>));  <span class="comment">// hi~lily</span></span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(a.getName.apply(b, [<span class="string">&#x27;hi~&#x27;</span>]))  <span class="comment">// hi~lily</span></span><br><span class="line">let name = a.getName.bind(b, <span class="string">&#x27;hello~&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(name());  <span class="comment">// hello~lily</span></span><br></pre></td></tr></table></figure>
<p>A 对象有个 getName 的方法，B 对象也需要临时使用同样的方法，那么这时候我们是单独为 B 对象扩展一个方法，还是借用一下 A 对象的方法呢？当然是可以借用 A 对象的 getName 方法，既达到了目的，又节省重复定义，节约内存空间。</p>
<h4 id="new的实现"><a href="#new的实现" class="headerlink" title="new的实现"></a>new的实现</h4><p>执行 new 的过程</p>
<ul>
<li>让实例可以访问到私有属性</li>
<li>让实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性</li>
<li>构造函数返回的最后结果是引用数据类型<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params">ctor, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> ctor !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;ctor must be a function&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    obj.<span class="property">__proto__</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(ctor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">    <span class="keyword">let</span> res = ctor.<span class="title function_">apply</span>(obj,  [...args]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isObject = <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> res !== <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> isFunction = <span class="keyword">typeof</span> res === <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> isObect || isFunction ? res : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="call的实现"><a href="#call的实现" class="headerlink" title="call的实现"></a>call的实现</h4><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">Function.prototype.call = <span class="keyword">function</span> <span class="params">(context, <span class="rest_arg">...args</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || window;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> result = eval(<span class="string">&#x27;context.fn(...args)&#x27;</span>);</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="apply的实现"><a href="#apply的实现" class="headerlink" title="apply的实现"></a>apply的实现</h4><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">Function.prototype.call = <span class="keyword">function</span> <span class="params">(context, <span class="rest_arg">...args</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || window;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> result = eval(<span class="string">&#x27;context.fn(...args)&#x27;</span>);</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
实现 call 和 apply 的关键就在 eval 这行代码。其中显示了用 context 这个临时变量来指定上下文，然后还是通过执行 eval 来执行 context.fn 这个函数，最后返回 result。<h4 id="bind的实现"><a href="#bind的实现" class="headerlink" title="bind的实现"></a>bind的实现</h4>bind 的实现思路基本和 apply 一样，但是在最后实现返回结果这里，bind 和 apply 有着比较大的差异，bind 不需要直接执行，因此不再需要用 eval ，而是需要通过返回一个函数的方式将结果返回，之后再通过执行这个结果，得到想要的执行效果。<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">Function.prototype.bind = <span class="keyword">function</span> <span class="params">(context, <span class="rest_arg">...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;this must be a function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> fbound = <span class="keyword">function</span> <span class="params">()</span> &#123;</span><br><span class="line">        self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> self ? <span class="keyword">this</span> : context, args.concat(Array.prototype.slice.call(arguments)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">      fbound.prototype = Object.create(<span class="keyword">this</span>.prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fbound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
从上面的代码中可以看到，实现 bind 的核心在于返回的时候需要返回一个函数，故这里的 fbound 需要返回，但是在返回的过程中原型链对象上的属性不能丢失。因此这里需要用Object.create 方法，将 this.prototype 上面的属性挂到 fbound 的原型上面，最后再返回 fbound。这样调用 bind 方法接收到函数的对象，再通过执行接收的函数，即可得到想要的结果。</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h4 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h4><blockquote>
<p>红宝书闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。<br>MDN：一个函数和对其周围状态的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。</p>
</blockquote>
<h4 id="闭包基本概念"><a href="#闭包基本概念" class="headerlink" title="闭包基本概念"></a>闭包基本概念</h4><p>通俗地讲解一下：闭包其实就是一个可以访问其他函数内部变量的函数。即一个定义在函数内部的函数，或者直接说闭包是个内嵌函数也可以。（函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。）<br>因为通常情况下，函数内部变量是无法在外部访问的（即全局变量和局部变量的区别），因此使用闭包的作用，就具备实现了能在外部访问某个函数内部变量的功能，让这些内部变量的值始终可以保存在内存中。下面我们通过代码先来看一个简单的例子。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="built_in">console</span>.<span class="built_in">log</span>(a);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br><span class="line"><span class="keyword">var</span> result = fun1();</span><br><span class="line">result();  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h4 id="闭包的表现形式"><a href="#闭包的表现形式" class="headerlink" title="闭包的表现形式"></a>闭包的表现形式</h4><ul>
<li>返回一个函数</li>
<li>在定时器、事件监听、Ajax 请求、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。请看下面这段代码，这些都是平常开发中用到的形式。<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定时器</span></span><br><span class="line">setTimeout(<span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;，<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line">$(<span class="string">&#x27;#app&#x27;</span>).click(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;Event Listener&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>作为函数参数传递的形式<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.<span class="built_in">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  bar(baz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">  <span class="comment">// 这就是闭包</span></span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 输出2，而不是1</span></span><br></pre></td></tr></table></figure></li>
<li>IIFE（立即执行函数），创建了闭包，保存了全局作用域（window）和当前函数的作用域，因此可以输出全局的变量<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">IIFE</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="built_in">console</span>.<span class="built_in">log</span>(a);  <span class="comment">// 输出2</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="循环中使用闭包解决-var-定义函数的问题"><a href="#循环中使用闭包解决-var-定义函数的问题" class="headerlink" title="循环中使用闭包解决 var 定义函数的问题"></a>循环中使用闭包解决 var 定义函数的问题</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span><span class="params">(var i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)</span></span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="built_in">function</span>() &#123;</span><br><span class="line">    console<span class="selector-class">.log</span>(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从控制台执行的结果可以看出来，结果输出的是 5 个 6，那么为什么都是 6 ？</p>
<blockquote>
<p>1.setTimeout 为宏任务，由于 JS 中单线程 eventLoop 机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后 setTimeout 中的回调才依次执行。<br>2.因为 setTimeout 函数也是一种闭包，往上找它的父级作用域链就是 window，变量 i 为 window 上的全局变量，开始执行 setTimeout 之前变量 i 已经就是 6 了，因此最后输出的连续就都是 6。</p>
</blockquote>
<h5 id="如何实现输出1-2-3-4-5？"><a href="#如何实现输出1-2-3-4-5？" class="headerlink" title="如何实现输出1,2,3,4,5？"></a>如何实现输出1,2,3,4,5？</h5><ul>
<li>利用 IIFE（立即执行函数）<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>;i++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">    setTimeout(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.<span class="built_in">log</span>(j)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当每次 for 循环时，把此时的变量 i 传递到定时器中，然后执行，改造之后的代码如下。</li>
<li>使用 ES6 中的 let<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
ES6 中新增的 let 定义变量的方式，使得 ES6 之后 JS 发生革命性的变化，让 JS 有了块级作用域，代码的作用域以块级为单位进行执行</li>
<li>定时器传入第三个参数<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span><span class="params">(var i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span></span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="built_in">function</span>(j) &#123;</span><br><span class="line">    console<span class="selector-class">.log</span>(j)</span><br><span class="line">  &#125;, <span class="number">0</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
setTimeout 作为经常使用的定时器，它是存在第三个参数的，日常工作中我们经常使用的一般是前两个，一个是回调函数，另外一个是时间，而第三个参数用得比较少。那么结合第三个参数，调整完之后的代码如下。<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span><span class="params">(var i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span></span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="built_in">function</span>(j) &#123;</span><br><span class="line">    console<span class="selector-class">.log</span>(j)</span><br><span class="line">  &#125;, <span class="number">0</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
从中可以看到，第三个参数的传递，可以改变 setTimeout 的执行逻辑，从而实现我们想要的结果，这也是一种解决循环输出问题的途径。</li>
</ul>
<h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h3><p>—————— 该篇文章继续学习中，未完待续 ——————</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx/1.18.0进行SSL证书配置</title>
    <url>/posts/5510b3d9.html</url>
    <content><![CDATA[<p>服务器：腾讯云服务器<br>nginx版本：nginx/1.18.0 <a href="http://nginx.org/en/download.html">nginx下载地址</a><br>CentOS:   CentOS Linux release 7.6.1810 (Core)</p>
<span id="more"></span>
<h3 id="查看安装模块"><a href="#查看安装模块" class="headerlink" title="查看安装模块"></a>查看安装模块</h3><ul>
<li>查看安装了哪些模块，<code>nginx -V</code> 显示的很乱，看起来不是很方便，如下：<br><img src="/posts/5510b3d9/1.png" alt="没排版的样式"></li>
<li>输入下面的命令，就可以很清晰查看安装了哪些模块了<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nginx</span> -V <span class="number">2</span>&gt;&amp;<span class="number">1</span> | sed <span class="string">&quot;s/\s\+--/\n --/g&quot;</span></span><br></pre></td></tr></table></figure>
<img src="/posts/5510b3d9/2.png" alt="排版后的样式"></li>
</ul>
<h3 id="配置SSL证书"><a href="#配置SSL证书" class="headerlink" title="配置SSL证书"></a>配置SSL证书</h3><ul>
<li>这里我用的是腾讯云服务器，点击下载证书<br><img src="/posts/5510b3d9/3.png" alt="下载位置"></li>
<li>下载后有个这个文件夹<br><img src="/posts/5510b3d9/4.png" alt="下载后文件夹"></li>
<li>打开文件夹，找到nginx文件<br><img src="/posts/5510b3d9/5.png" alt="图示"></li>
<li>打开nginx文件里面两个文件复制一下<br><img src="/posts/5510b3d9/6.png" alt="图示"></li>
<li>这个时候连接到云服务器<br>把刚刚nginx文件里面复制的两个文件，放在<code>/etc/nginx/conf</code>文件中<br><img src="/posts/5510b3d9/7.png" alt="图示"></li>
<li>通过<code>vim /etc/nginx/conf.d/default.conf</code>进行编辑配置，将下面的<code>www.yubo365.cn</code>换成你的域名<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="comment">#server_name  localhost;</span></span><br><span class="line">    <span class="attribute">server_name</span> www.yubo365.cn;</span><br><span class="line">    <span class="attribute">return</span>       <span class="number">301</span> https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;</span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#location / &#123;</span></span><br><span class="line">        <span class="comment">#root   /usr/share/nginx/html;</span></span><br><span class="line">        <span class="comment">#index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#error_page   500 502 503 504  /50x.html;</span></span><br><span class="line">    <span class="comment">#location = /50x.html &#123;</span></span><br><span class="line">        <span class="comment">#root   /usr/share/nginx/html;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    root           html;</span></span><br><span class="line">    <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">    <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">    <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">    <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">    <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">    <span class="comment">#    deny  all;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl;  <span class="comment"># nginx1.15之后用这个语法,老的语法是ssl on;</span></span><br><span class="line">    <span class="attribute">server_name</span>  service.yuming.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>   /etc/nginx/conf/1_www.yubo365.cn_bundle.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  /etc/nginx/conf/2_www.yubo365.cn.key;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;        </span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">       <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">       <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#location / &#123;</span></span><br><span class="line">       <span class="comment">#proxy_set_header Host $http_host;</span></span><br><span class="line">       <span class="comment">#proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span></span><br><span class="line">       <span class="comment">#proxy_set_header X-Real-Ip $remote_addr;</span></span><br><span class="line">       <span class="comment">#proxy_set_header X-NginX-Proxy true;</span></span><br><span class="line">       <span class="comment">#proxy_pass http://localhost:8081;</span></span><br><span class="line">       <span class="comment">#proxy_redirect off;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="开启80-443端口"><a href="#开启80-443端口" class="headerlink" title="开启80/443端口"></a>开启80/443端口</h3><p>进入到购买的腾讯云服务器后台，服务器安全组开启80/443端口，因为https默认的是443端口。  </p>
<ul>
<li>配置好以后，重启下服务器<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//关闭</span><br><span class="line">nginx -s quit</span><br><span class="line"></span><br><span class="line">//开启nginx</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure></li>
<li>访问<a href="https://www.yubo365.cn/">https://www.yubo365.cn/</a><br><img src="/posts/5510b3d9/8.png" alt="https图示"><br>可以看到小锁连接是绿色的说明已经配置成功了</li>
</ul>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯云服务器nginx安装配置</title>
    <url>/posts/a477be03.html</url>
    <content><![CDATA[<p>开始配置前，需要购买一个服务器 <a href="https://url.cn/NEdlZzvJ">腾讯云官网</a>，购买过后还需要你先去备案，从提交备案到管理局通过正常大概一个星期，下面是我的备案操作记录，被腾讯云客服打电话驳回一次，因为填写的备用电话打不通，需要注意：提交备案后注意保持电话畅通。</p>
<span id="more"></span>

<p><img src="/posts/a477be03/1.png" alt="我的备案截图"></p>
<h3 id="我的环境："><a href="#我的环境：" class="headerlink" title="我的环境："></a>我的环境：</h3><ul>
<li>服务器：腾讯云服务器</li>
<li>nginx版本：nginx/1.18.0 <a href="http://nginx.org/en/download.html">nginx下载地址</a></li>
<li>CentOS: CentOS Linux release 7.6.1810 (Core)</li>
</ul>
<h3 id="查看你的公网IP和私网IP"><a href="#查看你的公网IP和私网IP" class="headerlink" title="查看你的公网IP和私网IP"></a>查看你的公网IP和私网IP</h3><p><img src="/posts/a477be03/2.png" alt="查看ip"></p>
<h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><p>windows系统需要下载个连接服务器的客户端，xshell、xmanager等，根据自己喜欢的来选择 <a href="https://www.netsarang.com/zh/all-downloads/">下载地址</a>，我用的mac系统操作这里就直接打开终端，选择左上角的shell进行下图步骤操作就可，<br><img src="/posts/a477be03/3.png" alt="官网图"><br><img src="/posts/a477be03/4.png" alt="image.png"></p>
<ul>
<li>这里输入的服务器名称是购买服务器时候给你发的名称默认root，IP地址就是公网的IP地址<br><img src="/posts/a477be03/5.png" alt="image.png"><br><img src="/posts/a477be03/6.png" alt="image.png"></li>
<li>点击连接后，终端会弹出来，让输入密码<br><img src="/posts/a477be03/7.png" alt="输入密码"></li>
<li>输入完密码后，点击回车，即刻连接上了</li>
</ul>
<h3 id="用yum进行安装必要程序，安装一些服务和vim编辑器"><a href="#用yum进行安装必要程序，安装一些服务和vim编辑器" class="headerlink" title="用yum进行安装必要程序，安装一些服务和vim编辑器"></a>用yum进行安装必要程序，安装一些服务和vim编辑器</h3><p>先查看连接的linux服务器有么有安装yum（腾讯云默认是安装了）</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">rpm -<span class="keyword">qa</span> | <span class="keyword">grep</span> yum</span><br></pre></td></tr></table></figure>
<p><img src="/posts/a477be03/8.png" alt="查看有没有安装yum"></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ <span class="built_in">auto</span>conf pcre-devel make <span class="built_in">auto</span>make</span><br><span class="line">yum -y install wget httpd-tools vim</span><br></pre></td></tr></table></figure>
<ul>
<li>安装完成后，新建一个文件存放文件的文件夹<br><img src="/posts/a477be03/9.png" alt="新建文件夹"></li>
<li>再进入到文件夹分别新建下面几个文件<br><code>app</code>  放程序用<br><code>backup</code> 放备份文件<br><code>download</code> 下载的东西都放这里<br><code>logs</code> 日志放在这里<br><code>work</code> 工作文档都放这里<br><img src="/posts/a477be03/10.png" alt="新建文件"></li>
</ul>
<h3 id="nginx下载"><a href="#nginx下载" class="headerlink" title="nginx下载"></a>nginx下载</h3><ul>
<li>下载nginx <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> nginx</span><br></pre></td></tr></table></figure></li>
<li>下载完成后，查看一下版本<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nginx -v</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><p>在使用yum安装完Nginx后，需要知道系统中多了哪些文件，它们都安装到了那里。可以使用下面的命令进行查看。</p>
<ul>
<li><p>查看Nginx的安装目录</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rpm -ql nginx</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>rpm</code>是<code>linux</code>的<code>rpm</code>包管理工具，<code>-q</code> 代表询问模式，<code>-l</code> 代表返回列表，这样我们就可以找到nginx的所有安装位置了。</p>
</blockquote>
</li>
<li><p>nginx.conf文件解读<br><code>nginx.conf</code> 文件是<code>Nginx</code>总配置文件，在我们搭建服务器时经常调整的文件。</p>
</li>
<li><p>进入<code>etc/nginx</code>目录下，然后用 <code>vim</code>进行打开<code>nginx.conf</code>文件</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> /etc/nginx</span><br><span class="line"></span><br><span class="line"><span class="keyword">vim</span> nginx.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#运行用户，默认即是nginx，可以不进行设置</span></span><br><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="comment">#Nginx进程，一般设置为和CPU核数一样</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>; </span><br><span class="line"><span class="comment">#错误日志存放目录</span></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/<span class="literal">error</span>.log <span class="literal">warn</span>;</span><br><span class="line"><span class="comment">#进程pid存放位置</span></span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>; <span class="comment"># 单个后台进程的最大并发数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types; <span class="comment">#文件扩展名与类型映射表</span></span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream; <span class="comment">#默认文件类型</span></span><br><span class="line">    <span class="comment">#设置日志模式</span></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line">    <span class="comment">#nginx访问日志存放位置</span></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line">    <span class="comment">#开启高效传输模式</span></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#减少网络报文段的数量</span></span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line">    <span class="comment">#保持连接的时间，也叫超时时间</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">   <span class="comment">#开启gzip压缩</span></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    <span class="comment">#包含的子配置项位置和文件</span></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查看到<code>nginx.conf</code>文件中最底下部分有个<code>include /etc/nginx/conf.d/*.conf;</code><br>在通过命令进入到<code>/etc/nginx/conf.d</code>文件夹下面，通过<code>vim default.conf</code>打开文件</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">80</span>;   <span class="comment">#配置监听端口</span></span><br><span class="line">    server_name  localhost;  <span class="regexp">//</span>配置域名</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;     </span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   <span class="regexp">/usr/</span>share<span class="regexp">/nginx/</span>html;     <span class="comment">#服务默认启动目录</span></span><br><span class="line">        index  index.html index.htm;    <span class="comment">#默认访问文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;   # 配置404页面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;   <span class="comment">#错误状态码的显示页面，配置后需要重启</span></span><br><span class="line">    location = /<span class="number">50</span>x.html &#123;</span><br><span class="line">        root   <span class="regexp">/usr/</span>share<span class="regexp">/nginx/</span>html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    root           html;</span></span><br><span class="line">    <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">    <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">    <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">    <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">    <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">    <span class="comment">#    deny  all;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这里补充一下<code>vim</code>进行编辑的一个简单操作</p>
<ol>
<li>打开文件，首先进入 命令模式</li>
<li>按下 <code>i(insert)</code> 进入 编辑模式</li>
<li>按下 <code>esc</code>再按下 <code>: </code>进入 末行模式 ，以下为命令功能说明</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>英文</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>:w</code></td>
<td><code>write</code></td>
<td>保存</td>
</tr>
<tr>
<td><code>:q</code></td>
<td><code>quit</code></td>
<td>退出</td>
</tr>
<tr>
<td><code>:q!</code></td>
<td></td>
<td>强制退出</td>
</tr>
<tr>
<td><code>:wq</code></td>
<td><code>write &amp; quit</code></td>
<td>强制保存并退出</td>
</tr>
<tr>
<td><code>:x</code></td>
<td></td>
<td>保存并退出</td>
</tr>
</tbody></table>
<h3 id="nginx启动，关闭"><a href="#nginx启动，关闭" class="headerlink" title="nginx启动，关闭"></a>nginx启动，关闭</h3><ul>
<li>查看nginx有没有启动，如果出现三条记录就说明开启了<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps aux | grep nginx</span><br></pre></td></tr></table></figure>
<img src="/posts/a477be03/11.png" alt="查看nginx运行状态"></li>
<li>启动nginx<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure></li>
<li>停止nginx<br>方法一：立刻停止，无论程序有没有运行完，都立刻停止<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx  -s stop</span><br></pre></td></tr></table></figure>
方法二：从容停止，有未运行完的程序，运行完成后才停止<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure></li>
<li>killall 方法杀死进程<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">killall nginx</span><br></pre></td></tr></table></figure></li>
<li>查看端口<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -tlnp</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="自定义错误页面"><a href="#自定义错误页面" class="headerlink" title="自定义错误页面"></a>自定义错误页面</h3><p>我们在上面的时候看到了<code>/etc/nginx/conf.d/default.conf</code>文件中</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;   <span class="comment">#错误状态码的显示页面，配置后需要重启</span></span><br><span class="line">    location = /<span class="number">50</span>x.html &#123;</span><br><span class="line">        root   <span class="regexp">/usr/</span>share<span class="regexp">/nginx/</span>html;   <span class="regexp">//</span>出现上面状态错误的时候，进入的页面</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用域名设置虚拟主机"><a href="#使用域名设置虚拟主机" class="headerlink" title="使用域名设置虚拟主机"></a>使用域名设置虚拟主机</h3><p>修改<code>etc/nginx/conf.d</code>目录下的<code>default.conf</code> 文件，把原来的80端口虚拟主机改为以域名划分的虚拟主机。代码如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">server</span> &#123;</span><br><span class="line">    <span class="keyword">listen</span>       <span class="number">80</span>;</span><br><span class="line">    server_name  www.yubo365.cn;</span><br><span class="line">    <span class="keyword">location</span> / &#123;</span><br><span class="line">        root   /usr/<span class="keyword">share</span>/nginx/html;</span><br><span class="line">        <span class="keyword">index</span>  <span class="keyword">index</span>.html <span class="keyword">index</span>.htm;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这时候我们再重启服务，然后属于域名就可以看到了，这里找的是<code> /usr/share/nginx/html</code>文件下面的 <code>index.html</code>文件</p>
<h3 id="设置反向代理"><a href="#设置反向代理" class="headerlink" title="设置反向代理"></a>设置反向代理</h3><p>正常代理的是ip地址，这里用域名也是可以的</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen <span class="number">80</span>;</span><br><span class="line">        server_name www.yubo365.cn;</span><br><span class="line">        <span class="keyword">location</span> <span class="title">/ &#123;</span></span><br><span class="line"><span class="title">               proxy_pass</span> https://baidu.com;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它反向代理指令：</p>
<ul>
<li>proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。</li>
<li>proxy_connect_timeout:配置Nginx与后端代理服务器尝试建立连接的超时时间。</li>
<li>proxy_read_timeout : 配置Nginx向后端服务器组发出read请求后，等待相应的超时时间。</li>
<li>proxy_send_timeout：配置Nginx向后端服务器组发出write请求后，等待相应的超时时间。</li>
<li>proxy_redirect :用于修改后端服务器返回的响应头中的Location和Refresh。</li>
</ul>
<h3 id="Nginx适配PC或移动设备"><a href="#Nginx适配PC或移动设备" class="headerlink" title="Nginx适配PC或移动设备"></a>Nginx适配PC或移动设备</h3><p>这里是在<code>/usr/share/nginx/</code>文件夹下面创建<code>pc</code>和<code>mobile</code>文件，然后通过<code>$http_user_agent </code>正则判断来选择进入到PC还是移动端的index</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">       root   <span class="regexp">/usr/</span>share<span class="regexp">/nginx/</span>pc;</span><br><span class="line">       <span class="keyword">if</span> (<span class="variable">$http_user_agent</span> ~* <span class="string">&quot;(Android|iPhone|Windows Phone|UC|Kindle)&quot;</span>)&#123;</span><br><span class="line">         root <span class="regexp">/usr/</span>share<span class="regexp">/nginx/m</span>obile;</span><br><span class="line">       &#125;</span><br><span class="line">       index  index.html;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="开启nginx的gzip压缩"><a href="#开启nginx的gzip压缩" class="headerlink" title="开启nginx的gzip压缩"></a>开启nginx的gzip压缩</h3><p>Gzip是网页的一种网页压缩技术，经过gzip压缩后，页面大小可以变为原来的30%甚至更小。更小的网页会让用户浏览的体验更好，速度更快，下面简单配置代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_comp_level 8;</span><br><span class="line">    gzip_types text/plain application/javascript text/css;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/a477be03/12.png" alt="部分代码"><br>配置好以后，重启服务，查看HTTP响应头信息。你可以看见Content-Encoding为gzip类型。<br><img src="/posts/a477be03/13.png" alt="浏览器截图"><br>Nginx提供了专门的gzip模块，并且模块中的指令非常丰富，下面可以查看：</p>
<ul>
<li>gzip :  该指令用于开启（on）或 关闭（off）gzip模块。</li>
<li>gzip_buffers : 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。</li>
<li>gzip_comp_level : gzip压缩比，压缩级别是1-9，1的压缩级别最低，9的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。</li>
<li>gzip_disable : 可以通过该指令对一些特定的User-Agent不使用压缩功能。</li>
<li>gzip_min_length:设置允许压缩的页面最小字节数，页面字节数从相应消息头的Content-length中进行获取。</li>
<li>gzip_http_version：识别HTTP协议版本，其值可以是1.1.或1.0.</li>
<li>gzip_proxied : 用于设置启用或禁用从代理服务器上收到相应内容gzip压缩。</li>
<li>gzip_vary : 用于在响应消息头中添加Vary：Accept-Encoding,使代理服务器根据请求头中的Accept-Encoding识别是否启用gzip压缩。</li>
</ul>
<blockquote>
<p>最后分享一个可以在线压缩检测的站长工具<a href="https://tool.chinaz.com/Gzips">https://tool.chinaz.com/Gzips</a></p>
</blockquote>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>腾讯云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex</title>
    <url>/posts/vuex.html</url>
    <content><![CDATA[<h3 id="安装Vuex"><a href="#安装Vuex" class="headerlink" title="安装Vuex"></a>安装Vuex</h3><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">npm install vuex <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
<h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><p>新建一个<code>store</code>文件夹，在文件夹下面新建<code>index.js</code>文件</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import Vue <span class="keyword">from</span> &#x27;vue&#x27;</span><br><span class="line">import Vuex <span class="keyword">from</span> &#x27;vuex&#x27;</span><br><span class="line"></span><br><span class="line">// 使用vuex</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">state</span> = &#123;</span><br><span class="line">  count:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> modules = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 导出 让外部可以引用</span><br><span class="line">export <span class="keyword">default</span> new Vuex.Store(&#123;</span><br><span class="line">  <span class="keyword">state</span>,</span><br><span class="line">  mutations,</span><br><span class="line">  getters,</span><br><span class="line">  actions</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>在<code>main.js</code>中引入<code>store/index.js</code>文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="添加修改state中值的方法"><a href="#添加修改state中值的方法" class="headerlink" title="添加修改state中值的方法"></a>添加修改state中值的方法</h3><p>在<code>store/index.js</code>文件，<code>mutations</code>方法中设置方法</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  add(<span class="keyword">state</span>)&#123;</span><br><span class="line">    <span class="keyword">state</span>.count++</span><br><span class="line">  &#125;,</span><br><span class="line">  reduce(<span class="keyword">state</span>)&#123;</span><br><span class="line">    <span class="keyword">state</span>.count--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在模板中添加调用<code>mutations</code>里面设置的方法</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>store值：</span><span class="template-variable">&#123;&#123;<span class="name">$store.state.count</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.commit(&#x27;add&#x27;)&quot;</span>&gt;</span>加<span class="tag">&lt;/<span class="name">button</span>&gt;</span> | </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.commit(&#x27;reduce&#x27;)&quot;</span>&gt;</span>减<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="state访问状态对象"><a href="#state访问状态对象" class="headerlink" title="state访问状态对象"></a>state访问状态对象</h3><p>访问state状态对象中的的方式有好几种，</p>
<ul>
<li>方式一：通过computed访问<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">  newCount() &#123;</span><br><span class="line">    return this.<span class="variable">$store</span>.<span class="keyword">state</span>.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方式二：通过<code>mapState</code>访问<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要引入mapState</span></span><br><span class="line"><span class="keyword">import</span> &#123;mapState&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一：</span></span><br><span class="line">computed:&#123;</span><br><span class="line">  ...mapState([<span class="string">&quot;count&quot;</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二：</span></span><br><span class="line">computed:&#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">      <span class="keyword">count</span>:state=&gt;state.<span class="keyword">count</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mutations修改状态"><a href="#mutations修改状态" class="headerlink" title="mutations修改状态"></a>mutations修改状态</h3>获取<code>Mutations</code>里面的方法：   </li>
<li>方法一：mutations修改states中的值<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;button @<span class="attribute">click</span>=<span class="string">&quot;<span class="variable">$store</span>.commit(&#x27;add&#x27;)&quot;</span>&gt;加&lt;/button&gt; | </span><br><span class="line">&lt;button @<span class="attribute">click</span>=<span class="string">&quot;<span class="variable">$store</span>.commit(&#x27;reduce&#x27;)&quot;</span>&gt;减&lt;/button&gt;</span><br></pre></td></tr></table></figure>
如果需要传参数，可以如下传参写法<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;button @<span class="attribute">click</span>=<span class="string">&quot;<span class="variable">$store</span>.commit(&#x27;add&#x27;, 100)&quot;</span>&gt;加&lt;/button&gt; | </span><br><span class="line">&lt;button @<span class="attribute">click</span>=<span class="string">&quot;<span class="variable">$store</span>.commit(&#x27;reduce&#x27;)&quot;</span>&gt;减&lt;/button&gt;</span><br></pre></td></tr></table></figure>
在<code>/store/index.js</code>文件中，<code>data</code>就是触发方法时候的参数<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  add(<span class="keyword">state</span>,data)&#123;</span><br><span class="line">    <span class="keyword">state</span>.count +=data</span><br><span class="line">  &#125;,</span><br><span class="line">  reduce(<span class="keyword">state</span>)&#123;</span><br><span class="line">    <span class="keyword">state</span>.count--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方法二：<br>首先引入<code>mapMutations</code><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapState,mapMutations&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br></pre></td></tr></table></figure>
模板中写法<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add(100)&quot;</span>&gt;</span>加<span class="tag">&lt;/<span class="name">button</span>&gt;</span> | </span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;reduce&quot;</span>&gt;</span>减<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="getters操作"><a href="#getters操作" class="headerlink" title="getters操作"></a>getters操作</h3>getters操作是在获取数据之前进行的一种再编辑,相当于对数据的一个过滤和加工，可以把它看作<code>index.js</code>的计算属性。<br>写法如下：<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">    getterCount(<span class="keyword">state</span>)&#123;</span><br><span class="line">      return <span class="keyword">state</span>.count+<span class="number">10000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用：<br>方法一：<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">$store.getters.getterCount</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
方法二：<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapState,mapMutations,mapGetters&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line">computed:&#123;</span><br><span class="line">  ...mapGetters([<span class="string">&#x27;getterCount&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
方法三：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">  <span class="title function_">getterCount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>.<span class="property">getterCount</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="actions异步修改状态"><a href="#actions异步修改状态" class="headerlink" title="actions异步修改状态"></a>actions异步修改状态</h3>如果需要执行异步操作，就使用action，当异步操作完成，如果修改状态状态，再调用mutations修改状态，因为所有的状态修改都需要mutations，下面例子：<br>在<code>store/index.js</code>文件中<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="comment">// 两个参数</span></span><br><span class="line">  <span class="comment">// 参数1：上下文，有所有需要的state,commit, getters等成员</span></span><br><span class="line">  <span class="comment">// 参数2：额外的数据，传值用的</span></span><br><span class="line">  <span class="title function_">addAsync</span>(<span class="params">context,payload</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(context)</span><br><span class="line">    <span class="comment">// 延时调用mutations</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      context.<span class="title function_">commit</span>(<span class="string">&#x27;add&#x27;</span>,payload)</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>context</code>文中内容<br><img src="/posts/vuex/1.png" alt="action上下文"><br>模板中使用<br>方法一：<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的dispatch是action的固定用法，就好比mutation中的commit</span></span><br><span class="line">&lt;button <span class="meta">@click</span>=<span class="string">&quot;<span class="subst">$store</span>.dispatch(&#x27;addAsync&#x27;,9999)&quot;</span>&gt;Action&lt;/button&gt;</span><br></pre></td></tr></table></figure>
方法二：<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;addAsync(9999)&quot;</span>&gt;Action&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;mapState,mapMutations,mapGetters,mapActions&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">  ...mapActions([<span class="string">&#x27;addAsync&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="module模块"><a href="#module模块" class="headerlink" title="module模块"></a>module模块</h3>可以将单一状态拆分成多个模块，每个模块都可以有自己的<code>state</code>、<code>mutation</code>、<code>action</code>等，一般当状态特别多的时候才会用，在<code>store</code>文件夹下创建一个<code>module</code>文件夹，在里面建<code>a.js</code>、<code>b.js</code>文件.</li>
</ul>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">// a.js文件</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">state</span> = &#123;</span><br><span class="line">    a_module:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="keyword">state</span>,</span><br><span class="line">  mutations,</span><br><span class="line">  getters,</span><br><span class="line">  actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">// b.js</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">state</span> = &#123;</span><br><span class="line">    b_module:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="keyword">state</span>,</span><br><span class="line">  mutations,</span><br><span class="line">  getters,</span><br><span class="line">  actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>index.js</code>中引入模块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;./module/a&#x27;</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&#x27;./module/b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> modules = &#123;</span><br><span class="line">  a,</span><br><span class="line">  b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出 让外部可以引用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  getters,</span><br><span class="line">  actions,</span><br><span class="line">  modules</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="variable">&lt;div&gt;</span>&#123;&#123;<span class="variable">$store</span>.<span class="keyword">state</span>.a.a_module&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>开启命名空间</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">// a.js 和 b.js</span><br><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">  namespaced: true,</span><br><span class="line">  <span class="keyword">state</span>,</span><br><span class="line">  mutations,</span><br><span class="line">  getters,</span><br><span class="line">  actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>index.js注册引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;./module/a&#x27;</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&#x27;./module/b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> modules = &#123;</span><br><span class="line">  a,</span><br><span class="line">  b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出 让外部可以引用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  getters,</span><br><span class="line">  actions,</span><br><span class="line">  modules</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>模板中使用</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">import &#123;mapState,mapMutations,mapGetters,mapActions&#125; from <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line">computed:&#123;</span><br><span class="line">  <span class="regexp">//</span> 参数<span class="number">1</span>： 命名空间名字，</span><br><span class="line">  <span class="regexp">//</span> 参数<span class="number">2</span>： 状态名</span><br><span class="line">  ...mapState(<span class="string">&#x27;a&#x27;</span>,[<span class="string">&#x27;a_module&#x27;</span>])</span><br><span class="line">&#125;</span><br><span class="line">methods:&#123;</span><br><span class="line">  ...mapActions(<span class="string">&#x27;命名空间名&#x27;</span>,[<span class="string">&#x27;mutations方法名&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Vuex插件"><a href="#Vuex插件" class="headerlink" title="Vuex插件"></a>Vuex插件</h3><ul>
<li>Vuex的插件就是一个函数</li>
<li>这个函数接收一个store的参数</li>
</ul>
<p>Vuex插件使用</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">const myPlugin = <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// store 初始化</span></span><br><span class="line">    store.subscribe( <span class="function">(<span class="params">mutation, state</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 每次mutation之后调用</span></span><br><span class="line">        <span class="comment">// mutation的格式为&#123;type,payload&#125;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">store</span> = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title function_ invoke__">Store</span>(&#123;</span><br><span class="line">    <span class="attr">plugins</span>: [myPlugin]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="简单模拟Vuex"><a href="#简单模拟Vuex" class="headerlink" title="简单模拟Vuex"></a>简单模拟Vuex</h3><h4 id="基本机构"><a href="#基本机构" class="headerlink" title="基本机构"></a>基本机构</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _Vue = <span class="literal">null</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">install</span>(<span class="params">Vue</span>)&#123;</span><br><span class="line">    _Vue = <span class="title class_">Vue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title class_">Store</span>,</span><br><span class="line">    install</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="install"><a href="#install" class="headerlink" title="install"></a>install</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _Vue = <span class="literal">null</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">install</span>(<span class="params">Vue</span>)&#123;</span><br><span class="line">    _Vue = <span class="title class_">Vue</span></span><br><span class="line">    <span class="comment">// intall中获取不到vue根实例，通过混入来获取vue实例</span></span><br><span class="line">    _Vue.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">        <span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 判断当前vue实例的$options中是否是store,</span></span><br><span class="line">            <span class="comment">// 如果是组件实例，没有store选项，就不需要做这件事情</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">store</span>)&#123;</span><br><span class="line">                _Vue.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$store</span> = <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">store</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title class_">Store</span>,</span><br><span class="line">    install</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _Vue = <span class="literal">null</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>)&#123;</span><br><span class="line">        <span class="comment">// options成员解构出来，</span></span><br><span class="line">        <span class="comment">// 为了用户创建vuex时候，没有传入相应的选项，设置了一个默认值&#123;&#125;</span></span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">            state = &#123;&#125;,</span><br><span class="line">            getters = &#123;&#125;,</span><br><span class="line">            mutations = &#123;&#125;,</span><br><span class="line">            actions = &#123;&#125;</span><br><span class="line">        &#125; = options</span><br><span class="line">        <span class="comment">// 因为state是响应式的，响应式处理</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = _Vue.<span class="title function_">observable</span>(state)</span><br><span class="line">        <span class="comment">// getters是一个对象，对象中有一些方法，</span></span><br><span class="line">        <span class="comment">// 这些方法都需要state参数，并且都有返回值，</span></span><br><span class="line">        <span class="comment">// 也就是对state做一些处理，然后将处理的结果返回</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getters</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">keys</span>(getters).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 通过defineProperty 转成了getters访问器，这里key就是方法的名字</span></span><br><span class="line">            <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>.<span class="property">getters</span>,key,&#123;</span><br><span class="line">                <span class="comment">// 返回key在getters中的到的方法调用的结果</span></span><br><span class="line">                <span class="attr">get</span>:<span class="function">()=&gt;</span>getters[key](state)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 将mutations 和 actions存到对应的属性中，在commit和dispatch中获取</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_mutations</span> = mutations</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_actions</span> = actions</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数1：_mutations中方法的名字</span></span><br><span class="line">    <span class="comment">// 参数2：调用方法时传入的参数</span></span><br><span class="line">    commit (<span class="keyword">type</span>, payload)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_mutations</span>[<span class="keyword">type</span>](<span class="variable language_">this</span>.<span class="property">state</span>,payload)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数1：_actions中方法的名字</span></span><br><span class="line">    <span class="comment">// 参数2：调用方法时传入的参数</span></span><br><span class="line">    <span class="title function_">dispatch</span>(<span class="params"><span class="keyword">type</span>,payload</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_actions</span>[<span class="keyword">type</span>](<span class="variable language_">this</span>,payload)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">install</span>(<span class="params">Vue</span>)&#123;</span><br><span class="line">    _Vue = <span class="title class_">Vue</span></span><br><span class="line">    <span class="comment">// intall中获取不到vue根实例，通过混入来获取vue实例</span></span><br><span class="line">    _Vue.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">        <span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 判断当前vue实例的$options中是否是store,</span></span><br><span class="line">            <span class="comment">// 如果是组件实例，没有store选项，就不需要做这件事情</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">store</span>)&#123;</span><br><span class="line">                _Vue.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$store</span> = <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">store</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title class_">Store</span>,</span><br><span class="line">    install</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>HybridApp</title>
    <url>/posts/449b5459.html</url>
    <content><![CDATA[<p>为了开发Hybrid App，在vue项目中通过对WebViewJavaScriptBridge第三方库的封装，创建一个桥梁，实现H5和android、ios的通信。也可以去github查看详细的介绍<a href="https://github.com/marcuswestin/WebViewJavascriptBridge">WebViewJavascriptBridge</a></p>
<span id="more"></span>
<h3 id="新建封装文件"><a href="#新建封装文件" class="headerlink" title="新建封装文件"></a>新建封装文件</h3><p>创建<code>src/utils/jsBridge.js</code>文件，用于封装<code>WebViewJavascriptBridge</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">App</span> = &#123;&#125;</span><br><span class="line"><span class="comment">// 计数</span></span><br><span class="line"><span class="keyword">let</span> failNum = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取型号</span></span><br><span class="line"><span class="title class_">App</span>.<span class="property">userAgent</span> = navigator.<span class="property">userAgent</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否在android APP中运行</span></span><br><span class="line"><span class="title class_">App</span>.<span class="property">isAndroidApp</span> = <span class="regexp">/application_ccicAndroid/i</span>.<span class="title function_">test</span>(<span class="title class_">App</span>.<span class="property">userAgent</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否在iPhone APP中运行</span></span><br><span class="line"><span class="title class_">App</span>.<span class="property">isiPhoneApp</span> = <span class="regexp">/application_ccicIos/i</span>.<span class="title function_">test</span>(<span class="title class_">App</span>.<span class="property">userAgent</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里主要是注册 OC 将要调用的 JS 方法。</span></span><br><span class="line"><span class="title class_">App</span>.<span class="property">setupWebViewJavascriptBridge</span> = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行监听 &amp;&amp; 检测 JSBridge需要一个契机去告诉JS，我准备好了，你可以来调用我的方法了</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="title class_">WebViewJavascriptBridge</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;WebViewJavascriptBridgeReady&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="title function_">callback</span>(<span class="title class_">WebViewJavascriptBridge</span>);&#125;,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>) &#123; <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="title class_">WebViewJavascriptBridge</span>); &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>) &#123; <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>.<span class="title function_">push</span>(callback); &#125;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span> = [callback]; <span class="comment">// 创建一个 WVJBCallbacks 全局属性数组，并将 callback 插入到数组中。</span></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">WVJBIframe</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>); <span class="comment">// 创建一个 iframe 元素</span></span><br><span class="line">    <span class="title class_">WVJBIframe</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>; <span class="comment">// 不显示</span></span><br><span class="line">    <span class="title class_">WVJBIframe</span>.<span class="property">src</span> = <span class="string">&#x27;wvjbscheme://__BRIDGE_LOADED__&#x27;</span>; <span class="comment">// 设置 iframe 的 src 属性</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">appendChild</span>(<span class="title class_">WVJBIframe</span>); <span class="comment">// 把 iframe 添加到当前文导航上。</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">removeChild</span>(<span class="title class_">WVJBIframe</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与原生交互方法</span></span><br><span class="line"><span class="title class_">App</span>.<span class="property">callNative</span> = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">App</span>.<span class="property">isiPhoneApp</span>) &#123;</span><br><span class="line">        <span class="title class_">App</span>.<span class="title function_">setupWebViewJavascriptBridge</span>(<span class="keyword">function</span>(<span class="params">bridge</span>) &#123;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        * 封装 JS 调用了 OC 的方法</span></span><br><span class="line"><span class="comment">        * data.fun  是传递给 OC 的方法名</span></span><br><span class="line"><span class="comment">        * data.data 是传递给 OC 的数据</span></span><br><span class="line"><span class="comment">        * function  是 JS 调用完毕之后OC的回调</span></span><br><span class="line"><span class="comment">        * responseData 是 OC 传递过来的数据.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// jsbridge.callHandler是JS调Native方法的核心</span></span><br><span class="line">        bridge.<span class="title function_">callHandler</span>(data.<span class="property">fun</span>, data.<span class="property">data</span>, <span class="keyword">function</span> <span class="title function_">responseCallback</span>(<span class="params">responseData</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> data.<span class="property">callback</span> === <span class="string">&#x27;function&#x27;</span>) &#123; </span><br><span class="line">                data.<span class="title function_">callback</span>(responseData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title class_">App</span>.<span class="property">isAndroidApp</span>) &#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    *andorid从老系统返回时偶尔报错callHandler不是一个function，</span></span><br><span class="line"><span class="comment">    *应该是还未注入到webview，使用setTimeout反复调用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((!<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>) || (!<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>.<span class="property">callHandler</span>)) &#123;</span><br><span class="line">      failNum++;</span><br><span class="line">      <span class="keyword">if</span> (failNum &gt; <span class="number">50</span>) &#123;<span class="keyword">return</span>;&#125; <span class="comment">// 设置失败超过50次后停止</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="title class_">App</span>.<span class="title function_">callNative</span>(data);&#125;, <span class="number">300</span>) </span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 封装 JS 调用了安卓方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>.<span class="title function_">callHandler</span>(data.<span class="property">fun</span>, data.<span class="property">data</span>, <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> responseDataJson = &#123;&#125;;</span><br><span class="line">      <span class="keyword">if</span> (res) &#123;responseDataJson = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(res);&#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> data.<span class="property">callback</span> === <span class="string">&#x27;function&#x27;</span>) &#123;data.<span class="title function_">callback</span>(responseDataJson);&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="调取App原生方法"><a href="#调取App原生方法" class="headerlink" title="调取App原生方法"></a>调取App原生方法</h3><p>在<code>jsBridge.js</code>中封装设置调取原生的方法，下面的<code>fun方法名</code>是需要跟原生小伙伴商量确定的，这里封装的<code>app.方法名</code>习惯性的和调取原生的方法名一致，方便管理。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">app.<span class="keyword">fun</span>方法名 = function(req)&#123;</span><br><span class="line">  app.callNative(&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span>: &#x27;<span class="keyword">fun</span>方法名&#x27;,</span></span><br><span class="line">    <span class="keyword">data</span>: &#123;</span><br><span class="line">      参数<span class="number">1</span>: req.aaa,</span><br><span class="line">    &#125;,</span><br><span class="line">    callback: req.<span class="keyword">fun</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="项目中使用"><a href="#项目中使用" class="headerlink" title="项目中使用"></a>项目中使用</h3><p>在vue项目中使用，在<code>main.js</code>中引入封装的<code>jsBridge.js</code></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">import<span class="built_in"> bridge </span><span class="keyword">from</span> <span class="string">&#x27;/utils/jsBridge&#x27;</span>;</span><br><span class="line">Vue.prototype.<span class="variable">$bridge</span> =<span class="built_in"> bridge; </span></span><br></pre></td></tr></table></figure>
<h3 id="js调原生使用"><a href="#js调原生使用" class="headerlink" title="js调原生使用"></a>js调原生使用</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">let <span class="keyword">data</span> = &#123;</span><br><span class="line">  aaa:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  bbb:<span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.$bridge.<span class="keyword">fun</span>方法名( <span class="keyword">data</span> )</span><br></pre></td></tr></table></figure>
<h3 id="OC主动调用-JS-的方法"><a href="#OC主动调用-JS-的方法" class="headerlink" title="OC主动调用 JS 的方法"></a>OC主动调用 JS 的方法</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明 OC 需要主动调用 JS 的方法</span></span><br><span class="line">app.setup<span class="constructor">WebViewJavascriptBridge(<span class="params">function</span>(<span class="params">bridge</span>)</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* testFun： 是注入到桥梁中 JS 函数的别名。以供 OC 端调用。</span></span><br><span class="line"><span class="comment">* data：    OC 端传递过来的数据。</span></span><br><span class="line"><span class="comment">* responseCallback：JS 调用在被 OC 调用完毕之后，向 OC 端传递的数据的一个回调。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    bridge.register<span class="constructor">Handler(&#x27;<span class="params">testFun</span> &#x27;, <span class="params">function</span>(<span class="params">data</span>,<span class="params">responseCallback</span>)</span>&#123;</span><br><span class="line">        testFun (data)  <span class="comment">// 此处用的方法名和桥梁中注册的方法名一致，个人习惯，也方便管理</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 官方给出下面两种调用方式，可以根据自己项目情况来选择合适的方法：</span></span><br><span class="line">bridge.register<span class="constructor">Handler(<span class="string">&quot;showAlert&quot;</span>, <span class="params">function</span>(<span class="params">data</span>)</span> &#123; alert(data) &#125;)</span><br><span class="line">bridge.register<span class="constructor">Handler(<span class="string">&quot;getCurrentPageUrl&quot;</span>, <span class="params">function</span>(<span class="params">data</span>, <span class="params">responseCallback</span>)</span> &#123;</span><br><span class="line">    response<span class="constructor">Callback(<span class="params">document</span>.<span class="params">location</span>.<span class="params">toString</span>()</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>完成上面操作后，就完成了 <code>h5</code> 和 <code>App</code> 之间桥梁打通操作，后面只需要跟<code>原生</code>商量方法名即可。</p>
]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>HybridApp</tag>
      </tags>
  </entry>
  <entry>
    <title>【解决】无法将“XXX”项识别为 cmdlet、函数、脚本文件或可运行程序的名称……</title>
    <url>/posts/987e7249.html</url>
    <content><![CDATA[<h3 id="进入PowerShell-模式"><a href="#进入PowerShell-模式" class="headerlink" title="进入PowerShell 模式"></a>进入PowerShell 模式</h3><p>查看当前所有作用域 </p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Get</span><span class="operator">-</span><span class="variable">ExecutionPolicy</span> <span class="operator">-</span><span class="built_in">List</span> </span><br></pre></td></tr></table></figure>
<p><img src="/posts/987e7249/1.png" alt="查看作用域"><br>上图显示就最后一个作用域有权限，其他作用域都没有权限，那么我们就需要去给它设置权限</p>
<h4 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h4><p><code>Set-ExecutionPolicy RemoteSigned -Scope &lt; scopeName &gt;</code>,设置当前用户作用域具备权限，具体设置格</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Set</span>-ExecutionPolicy RemoteSigned -<span class="keyword">Scope</span> CurrentUser</span><br></pre></td></tr></table></figure>
<p><img src="/posts/987e7249/2.png" alt="查看作用域"><br>按照上面的格式，执行需要加权限的作用域，然后再去尝试之前的方法，发现就不会报错提示了。</p>
]]></content>
      <categories>
        <category>解决问题</category>
      </categories>
      <tags>
        <tag>解决问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next 主题添加 Valine 评论系统</title>
    <url>/posts/f65b37a2.html</url>
    <content><![CDATA[<h3 id="注册-LeanCloud"><a href="#注册-LeanCloud" class="headerlink" title="注册 LeanCloud"></a>注册 LeanCloud</h3><p>Valine 是基于 LeanCloud 作为数据存储的，所以需要注册一个账号。注册完成后，进入控制台</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建一个应用 -&gt; 输入应用名称 -&gt; 选择<code>开发版</code> -&gt; 点击创建</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>创建完成后，打开应用，点击左边的<code>存储</code>如下图：<br><img src="/posts/f65b37a2/chunchu.png" alt="存储"><br>查看数据下面有没有<code>Counter</code>和<code>Comment</code>两个Classes，如果没有，点击<code>创建Class</code>，输入对应的<code>Counter</code>和<code>Comment</code>名字，选择<code>无限制</code>，点击创建，创建完成后，如下：<br><img src="/posts/f65b37a2/class.png" alt="class"><br>创建完上面两个class后，找到<code>设置栏</code>，点击安全中心，在服务开关栏中，打开数据存储，其它的全关掉，在Web安全域名中，填写博客的域名地址：<br><img src="/posts/f65b37a2/shezhi.png" alt="设置"><br>同样在<code>设置栏</code>下面，点击<code>应用Key</code>，获取到<code>AppID</code> 和 <code>Appkey</code>，然后进入到主题配置下进行配置。</p>
<h3 id="next主题中配置valine"><a href="#next主题中配置valine" class="headerlink" title="next主题中配置valine"></a>next主题中配置valine</h3><p>在<code>/themes/next/_config.yml</code>文件中搜索<code>valine</code>，配置上面生成的<code>AppID</code> 和 <code>Appkey</code>，language为<code>zh-cn</code>,<br><img src="/posts/f65b37a2/valine.png" alt="valine"><br>修改<code>valine.min.js</code>的cdn文件地址：移步到这里<a href="https://www.jsdelivr.com/package/npm/valine">valine</a> 选择最新版本的<code>Valine</code><br><img src="/posts/f65b37a2/minjs.png" alt="minjs"><br>然后将获取的<code>cdn</code>地址，到主题配置文件<code>_config.yml</code>中添加即可。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">valine: https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/npm/</span>valine@<span class="number">1.4</span>.<span class="number">14</span><span class="regexp">/dist/</span>Valine.min.js</span><br></pre></td></tr></table></figure>
<p>现在再重新启动项目就看可以看到评论功能了。</p>
<h3 id="Valine评论区不显示问题"><a href="#Valine评论区不显示问题" class="headerlink" title="Valine评论区不显示问题"></a>Valine评论区不显示问题</h3><ul>
<li>常见的：<ul>
<li>LeanCloud 中需要配置安全域名</li>
<li>LeanCloud 中需要有 Counter 和 Coment 两个Class.</li>
</ul>
</li>
<li>其他的可以参考：<a href="https://github.com/xCss/Valine/issues/172">https://github.com/xCss/Valine/issues/172</a></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题美化</title>
    <url>/posts/c2d19cb2.html</url>
    <content><![CDATA[<h3 id="彩色标签页"><a href="#彩色标签页" class="headerlink" title="彩色标签页"></a>彩色标签页</h3><h4 id="新建个性文件"><a href="#新建个性文件" class="headerlink" title="新建个性文件"></a>新建个性文件</h4><p>在 <code>themes/next/layout</code>文件夹下，新建<code>tag-color.swig</code>文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">var</span> alltags = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;tag-cloud-tags&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">var</span> tags = alltags[<span class="number">0</span>].<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;a&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;11111111111111&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">for</span> (<span class="keyword">var</span> i = tags.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">var</span> r=<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">75</span>+<span class="number">130</span>);</span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">var</span> g=<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">75</span>+<span class="number">100</span>);</span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">var</span> b=<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">75</span>+<span class="number">80</span>);</span></span><br><span class="line"><span class="language-javascript">       tags[i].<span class="property">style</span>.<span class="property">background</span> = <span class="string">&quot;rgb(&quot;</span>+r+<span class="string">&quot;,&quot;</span>+g+<span class="string">&quot;,&quot;</span>+b+<span class="string">&quot;)&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">     &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.tag-cloud-tags</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-family</span>: Helvetica, Tahoma, Arial;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-weight</span>: <span class="number">100</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">counter-reset</span>: tags;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.tag-cloud-tags</span> <span class="selector-tag">a</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding-right</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding-left</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">8px</span> <span class="number">5px</span> <span class="number">0px</span> <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.tag-cloud-tags</span> <span class="selector-tag">a</span><span class="selector-pseudo">:before</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">content</span>: <span class="string">&quot;🔖&quot;</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.tag-cloud-tags</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="language-css">     <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">5px</span> <span class="number">15px</span> <span class="number">0px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">4</span>);</span></span><br><span class="line"><span class="language-css">     <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.1</span>);</span></span><br><span class="line"><span class="language-css">     <span class="comment">/*box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);*/</span></span></span><br><span class="line"><span class="language-css">     <span class="attribute">transition-duration</span>: <span class="number">0.15s</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="引入新建文件"><a href="#引入新建文件" class="headerlink" title="引入新建文件"></a>引入新建文件</h4><p>在同目录下的<code>page.swig</code>文件中引入</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">include</span></span> &#x27;tag-color.swig&#x27; %&#125;</span></span><br></pre></td></tr></table></figure>
<p><img src="/posts/c2d19cb2/tagcolor.png" alt="tagcolor"></p>
<p>设置完成后<code>hexo g  &amp;&amp; hexo s</code>就可以预览效果了 <a href="https://www.yubo365.cn/tags">标签页地址</a></p>
<h3 id="设置canvas粒子时钟"><a href="#设置canvas粒子时钟" class="headerlink" title="设置canvas粒子时钟"></a>设置canvas粒子时钟</h3><p>通过该篇<a href="https://www.cnblogs.com/xiaohuochai/p/6368039.html">粒子时钟</a>内容的开发思想，整合到页面中</p>
<h4 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h4><p>在<code>/themes/next/layout/_custom/</code>目录下新建<code>clock.swig</code>文件,内容下载：<br><a href="https://cdn.jsdelivr.net/gh/leafjame/cdn/share/swig/clock.swig">clock.swig</a></p>
<h4 id="引入文件"><a href="#引入文件" class="headerlink" title="引入文件"></a>引入文件</h4><p>在<code>/themes/next/layout/_macro/sidebar.swig</code>文件中引入</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">include</span></span> &#x27;../_custom/clock.swig&#x27; %&#125;</span></span><br></pre></td></tr></table></figure>
<p>具体放在什么位置，根据自己喜欢来。</p>
<h3 id="网站运行时间"><a href="#网站运行时间" class="headerlink" title="网站运行时间"></a>网站运行时间</h3><p>在<code>/themes/next/layout/_custom/</code>目录下新建<code>runtime.swig</code>文件，然后将下面代码拷贝进去：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">&lt;span id=<span class="string">&quot;sitetime&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">&lt;script language=javascript&gt;</span><br><span class="line">	<span class="keyword">function</span> site<span class="constructor">Time()</span>&#123;</span><br><span class="line">		window.set<span class="constructor">Timeout(<span class="string">&quot;siteTime()&quot;</span>, 1000)</span>;</span><br><span class="line">		var seconds = <span class="number">1000</span>;</span><br><span class="line">		var minutes = seconds<span class="operator"> * </span><span class="number">60</span>;</span><br><span class="line">		var hours = minutes<span class="operator"> * </span><span class="number">60</span>;</span><br><span class="line">		var days = hours<span class="operator"> * </span><span class="number">24</span>;</span><br><span class="line">		var years = days<span class="operator"> * </span><span class="number">365</span>;</span><br><span class="line">		var today = <span class="keyword">new</span> <span class="constructor">Date()</span>;</span><br><span class="line">		var todayYear = today.get<span class="constructor">FullYear()</span>;</span><br><span class="line">		var todayMonth = today.get<span class="constructor">Month()</span>+<span class="number">1</span>;</span><br><span class="line">		var todayDate = today.get<span class="constructor">Date()</span>;</span><br><span class="line">		var todayHour = today.get<span class="constructor">Hours()</span>;</span><br><span class="line">		var todayMinute = today.get<span class="constructor">Minutes()</span>;</span><br><span class="line">		var todaySecond = today.get<span class="constructor">Seconds()</span>;</span><br><span class="line">                <span class="comment">/** </span></span><br><span class="line"><span class="comment">                * Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)</span></span><br><span class="line"><span class="comment">                * year - 作为date对象的年份，为4位年份值</span></span><br><span class="line"><span class="comment">                * month - 0-11之间的整数，做为date对象的月份</span></span><br><span class="line"><span class="comment">                * day - 1-31之间的整数，做为date对象的天数</span></span><br><span class="line"><span class="comment">                * hours - 0(午夜24点)-23之间的整数，做为date对象的小时数</span></span><br><span class="line"><span class="comment">                * minutes - 0-59之间的整数，做为date对象的分钟数</span></span><br><span class="line"><span class="comment">                * seconds - 0-59之间的整数，做为date对象的秒数</span></span><br><span class="line"><span class="comment">                * microseconds - 0-999之间的整数，做为date对象的毫秒数</span></span><br><span class="line"><span class="comment">                **/</span></span><br><span class="line">		var t1 = Date.<span class="constructor">UTC(2020,12,09,22,00,00)</span>; <span class="comment">//北京时间2018-2-13 00:00:00</span></span><br><span class="line">		var t2 = Date.<span class="constructor">UTC(<span class="params">todayYear</span>,<span class="params">todayMonth</span>,<span class="params">todayDate</span>,<span class="params">todayHour</span>,<span class="params">todayMinute</span>,<span class="params">todaySecond</span>)</span>;</span><br><span class="line">		var diff = t2-t1;</span><br><span class="line">		var diffYears = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>floor(diff/years);</span><br><span class="line">		var diffDays = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>floor((diff/days)-diffYears*<span class="number">365</span>);</span><br><span class="line">		var diffHours = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>floor((diff-(diffYears*<span class="number">365</span>+diffDays)*days)/hours);</span><br><span class="line">		var diffMinutes = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>floor((diff-(diffYears*<span class="number">365</span>+diffDays)*days-diffHours*hours)/minutes);</span><br><span class="line">		var diffSeconds = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>floor((diff-(diffYears*<span class="number">365</span>+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);</span><br><span class="line">		document.get<span class="constructor">ElementById(<span class="string">&quot;sitetime&quot;</span>)</span>.innerHTML=<span class="string">&quot; 已运行&quot;</span>+<span class="comment">/*diffYears+&quot; 年 &quot;+*/</span>diffDays+<span class="string">&quot; 天 &quot;</span>+diffHours+<span class="string">&quot; 小时 &quot;</span>+diffMinutes+<span class="string">&quot; 分钟 &quot;</span>+diffSeconds+<span class="string">&quot; 秒&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	site<span class="constructor">Time()</span>;</span><br></pre></td></tr></table></figure>
<p>修改BirthDay为建站时间<br>在<code>/themes/next/layout/_macro/sidebar.swig</code>同级文件目录下导入运行时间模块</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">include</span></span> &#x27;../_custom/runtime.swig&#x27; %&#125;</span></span><br></pre></td></tr></table></figure>
<p>在其他位置导入运行时间模块</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#123; <span class="name"><span class="built_in">partial</span></span>(<span class="name">&#x27;_custom/runtime.swig&#x27;</span>, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>重新打包，运行，然后就可以展示网站运行时间了</p>
<h3 id="美化url地址（-html后缀）"><a href="#美化url地址（-html后缀）" class="headerlink" title="美化url地址（.html后缀）"></a>美化url地址（.html后缀）</h3><p>hexo-next文章链接默认的生成规则是：<code>:year/:month/:day/:title</code>，是按照年、月、日、标题来生成的。</p>
<p>安装插件</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行此命令可能会不成功，提示你缺少相应的依赖，比如babel-eslint、mini-css-extract-plugin、webpack-cli…<br>使用npm命令安装即可，比如<code>npm install eslint@4.x babel-eslint@8 --save-dev</code></p>
</blockquote>
<p>修改根目录站点配置文件<code>config.yml</code>，改为：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">permalink:</span> posts/:abbrlink.html</span><br><span class="line"><span class="symbol">abbrlink:</span></span><br><span class="line"><span class="symbol">	alg:</span> crc32   <span class="meta">#算法： crc16(default) and crc32</span></span><br><span class="line"><span class="symbol">	rep:</span> hex     <span class="meta">#进制： dec(default) and hex</span></span><br></pre></td></tr></table></figure>
<p>这样设置过后地址栏可以展示.html后缀格式的地址了，但是这个时候会出现一个问题，之前使用<code>hexo-asset-image</code>插件生成的图片无法显示了<br>解决方法：<br>打开源文件<code>\node_modules\hexo-asset-image\index.js</code>,修改如下：<br><img src="/posts/c2d19cb2/imgshow.png" alt="imgshow"></p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> appendLink = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(/.*\/index\.html$/.test(<span class="keyword">link</span>))&#123;</span><br><span class="line">	appendLink = <span class="string">&#x27;index/&#x27;</span></span><br><span class="line">	<span class="built_in">var</span> endPos = <span class="keyword">link</span>.lastIndexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="built_in">var</span> endPos = <span class="keyword">link</span>.length - <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// var endPos = link.lastIndexOf(&#x27;/&#x27;) + 1;</span></span><br><span class="line">   <span class="comment">// link = link.substring(beginPos, endPos);</span></span><br><span class="line">   <span class="keyword">link</span> = <span class="keyword">link</span>.substring(beginPos, endPos) + <span class="string">&#x27;/&#x27;</span> + appendLink;</span><br></pre></td></tr></table></figure>
<p>重新运行，图片就可以正常展示了</p>
<h3 id="文章加密访问"><a href="#文章加密访问" class="headerlink" title="文章加密访问"></a>文章加密访问</h3><p>通过引入<a href="https://github.com/D0n9X1n/hexo-blog-encrypt">hexo-blog-encrypt</a>依赖包，进行加密.</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>一旦你输入了正确的密码, 它将会被存储在本地浏览器的 localStorage中. 按个按钮, 密码将会被清空. 若博客中又脚本, 它将会被正确地执行.</li>
<li>支持按标签加密.</li>
<li>所有的核心功能都是由原生的 API 所提供的. 在 Node.js中, 我们使用 <a href="https://nodejs.org/dist/latest-v12.x/docs/api/crypto.html">Crypto</a>. 在浏览器中, 我们使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API">Web Crypto API</a>.</li>
<li><a href="https://tools.ietf.org/html/rfc2898">PBKDF2</a>, <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">SHA256</a> 被用于分发密钥, <a href="https://csrc.nist.gov/publications/detail/sp/800-38a/final">AES256-CBC</a> 被用于加解密, 我们还使用 <a href="https://csrc.nist.gov/csrc/media/publications/fips/198/1/final/documents/fips-198-1_final.pdf">HMAC</a> 来验证密文的来源, 并确保其未被篡改.</li>
<li>我们广泛地使用 Promise 来进行异步操作, 以此确保线程不被杜塞.</li>
<li>加密页面多主题支持, 现在已经支持的主题有 [default, xray], 更多的主题正在开发中.</li>
<li>过时的浏览器将不能正常显示, 因此, 请升级您的浏览器.  </li>
</ul>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install </span>hexo-<span class="keyword">blog-encrypt </span>-S</span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li>文章信息头使用<br>将<code>password</code>字段，添加到文章信息头<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-01-11 14:11:00</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">bac123</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li>
<li>高级设置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">加密文章tag</span></span><br><span class="line"><span class="attr">date:</span> </span><br><span class="line"><span class="attr">password:</span> <span class="string">aabbcc</span></span><br><span class="line"><span class="attr">abstract:</span> <span class="string">该文章已加密,</span> <span class="string">请输入密码查看。</span></span><br><span class="line"><span class="attr">message:</span> <span class="string">该文章已加密,</span> <span class="string">请输入密码查看。</span></span><br><span class="line"><span class="attr">wrong_pass_message:</span> <span class="string">密码不正确，请重新输入！</span></span><br><span class="line"><span class="attr">wrong_hash_message:</span> <span class="string">文章不能被校验,</span> <span class="string">不过您还是能看看解密后的内容！</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li>
<li>在根目录下<code>_config.yml</code>中全局设置<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">  <span class="attr">abstract:</span> <span class="string">该文章已加密,</span> <span class="string">请输入密码查看.</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">该文章已加密,</span> <span class="string">请输入密码查看.</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码A</span>&#125;</span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码B</span>&#125;</span><br><span class="line">  <span class="attr">wrong_pass_message:</span> <span class="string">密码不正确，请重新输入.</span></span><br><span class="line">  <span class="attr">wrong_hash_message:</span> <span class="string">抱歉,</span> <span class="string">这个文章不能被校验,</span> <span class="string">不过您还是能看看解密后的内容.</span></span><br></pre></td></tr></table></figure>
注：若文章中采用_config.yml中的全局配置，则文章的tags只能有一个，若有多个tags，则失效。  </li>
</ul>
<h4 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h4><p>增加一个<code>theme</code>字段，可以选择的主题：<code>default</code>、<code>blink</code>、<code>shrink</code>、<code>flip</code>、<code>up</code>、<code>surge</code>、<code>wave</code>、<code>xray</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Security</span></span><br><span class="line"><span class="attr">encrypt:</span> <span class="comment"># hexo-blog-encrypt</span></span><br><span class="line">  <span class="attr">abstract:</span> <span class="string">有东西被加密了,</span> <span class="string">请输入密码查看.</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">您好,</span> <span class="string">这里需要密码.</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码A</span>&#125;</span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码B</span>&#125;</span><br><span class="line">  <span class="attr">theme:</span> <span class="string">xray</span></span><br><span class="line">  <span class="attr">wrong_pass_message:</span> <span class="string">抱歉,</span> <span class="string">这个密码看着不太对,</span> <span class="string">请再试试.</span></span><br><span class="line">  <span class="attr">wrong_hash_message:</span> <span class="string">抱歉,</span> <span class="string">这个文章不能被校验,</span> <span class="string">不过您还是能看看解密后的内容.</span></span><br></pre></td></tr></table></figure>
<h4 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h4><p>文章信息头 <code>&gt;</code> _config.yml (站点根目录下的) <code>&gt;</code> 默认配置  </p>
<p>使用<code>hexo clean</code> &amp;&amp; <code>hexo g</code> &amp;&amp; <code>hexo s</code>在本地预览加密的文章。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下安装nvm管理nodejs版本</title>
    <url>/posts/64663d25.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>nvm全名node.js version management，顾名思义是一个nodejs的版本管理工具。通过它可以安装和切换不同版本的nodejs。下面列出下载、安装及使用方法。</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>可在<a href="https://github.com/coreybutler/nvm-windows/releases">github</a>上下载最新版本,本次下载安装的是windows版本。打开网址我们可以看到有两个版本：</p>
<ul>
<li>nvm-noinstall.zip：绿色免安装版，但使用时需进行配置。</li>
<li>nvm-setup.zip：安装版，推荐使用<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="双击安装文件-nvm-setup-exe"><a href="#双击安装文件-nvm-setup-exe" class="headerlink" title="双击安装文件 nvm-setup.exe"></a>双击安装文件 nvm-setup.exe</h4><img src="/posts/64663d25/1.png" alt="安装文件"><h4 id="选择nvm安装路径"><a href="#选择nvm安装路径" class="headerlink" title="选择nvm安装路径"></a>选择nvm安装路径</h4><img src="/posts/64663d25/2.png" alt="选择nvm安装路径"><h4 id="选择nodejs路径"><a href="#选择nodejs路径" class="headerlink" title="选择nodejs路径"></a>选择nodejs路径</h4><img src="/posts/64663d25/3.png" alt="选择nodejs路径"><h4 id="确认安装即可"><a href="#确认安装即可" class="headerlink" title="确认安装即可"></a>确认安装即可</h4><img src="/posts/64663d25/4.png" alt="确认安装"><h4 id="安装完确认"><a href="#安装完确认" class="headerlink" title="安装完确认"></a>安装完确认</h4>安装成功则如下显示。可以看到里面列出了各种命令<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">  $ nvm</span><br><span class="line"></span><br><span class="line">Running <span class="built_in">version</span> <span class="number">1.1</span><span class="number">.7</span>.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">  nvm arch                     : Show <span class="keyword">if</span> node is running <span class="keyword">in</span> <span class="number">32</span> <span class="keyword">or</span> <span class="number">64</span> bit mode.</span><br><span class="line">  nvm install &lt;<span class="built_in">version</span>&gt; [arch] : The <span class="built_in">version</span> can be <span class="keyword">a</span> node.js <span class="built_in">version</span> <span class="keyword">or</span> <span class="string">&quot;latest&quot;</span> <span class="keyword">for</span> <span class="keyword">the</span> latest stable <span class="built_in">version</span>.</span><br><span class="line">                                 Optionally specify whether <span class="built_in">to</span> install <span class="keyword">the</span> <span class="number">32</span> <span class="keyword">or</span> <span class="number">64</span> bit <span class="built_in">version</span> (defaults <span class="built_in">to</span> <span class="keyword">system</span> arch).</span><br><span class="line">                                 Set [arch] <span class="built_in">to</span> <span class="string">&quot;all&quot;</span> <span class="built_in">to</span> install <span class="number">32</span> AND <span class="number">64</span> bit versions.</span><br><span class="line">                                 Add <span class="comment">--insecure to the end of this command to bypass SSL validation of the remote download server.</span></span><br><span class="line">  nvm list [available]         : List <span class="keyword">the</span> node.js installations. Type <span class="string">&quot;available&quot;</span> <span class="keyword">at</span> <span class="keyword">the</span> <span class="function"><span class="keyword">end</span> <span class="title">to</span> <span class="title">see</span> <span class="title">what</span> <span class="title">can</span> <span class="title">be</span> <span class="title">installed</span>. <span class="title">Aliased</span> <span class="title">as</span> <span class="title">ls</span>.</span></span><br><span class="line">  nvm <span class="keyword">on</span>                       : <span class="title">Enable</span> <span class="title">node</span>.<span class="title">js</span> <span class="title">version</span> <span class="title">management</span>.</span><br><span class="line">  nvm off                      : Disable node.js <span class="built_in">version</span> management.</span><br><span class="line">  nvm proxy [url]              : Set <span class="keyword">a</span> proxy <span class="built_in">to</span> use <span class="keyword">for</span> downloads. Leave [url] blank <span class="built_in">to</span> see <span class="keyword">the</span> current proxy.</span><br><span class="line">                                 Set [url] <span class="built_in">to</span> <span class="string">&quot;none&quot;</span> <span class="built_in">to</span> remove <span class="keyword">the</span> proxy.</span><br><span class="line">  nvm node_mirror [url]        : Set <span class="keyword">the</span> node mirror. Defaults <span class="built_in">to</span> <span class="keyword">https</span>://nodejs.org/dist/. Leave [url] blank <span class="built_in">to</span> use default url.</span><br><span class="line">  nvm npm_mirror [url]         : Set <span class="keyword">the</span> npm mirror. Defaults <span class="built_in">to</span> <span class="keyword">https</span>://github.com/npm/cli/archive/. Leave [url] blank <span class="built_in">to</span> default url.</span><br><span class="line">  nvm uninstall &lt;<span class="built_in">version</span>&gt;      : The <span class="built_in">version</span> must be <span class="keyword">a</span> specific <span class="built_in">version</span>.</span><br><span class="line">  nvm use [<span class="built_in">version</span>] [arch]     : Switch <span class="built_in">to</span> use <span class="keyword">the</span> specified <span class="built_in">version</span>. Optionally specify <span class="number">32</span>/<span class="number">64</span>bit architecture.</span><br><span class="line">                                 nvm use &lt;arch&gt; will continue <span class="keyword">using</span> <span class="keyword">the</span> selected <span class="built_in">version</span>, but <span class="keyword">switch</span> <span class="built_in">to</span> <span class="number">32</span>/<span class="number">64</span> bit mode.</span><br><span class="line">  nvm root [path]              : Set <span class="keyword">the</span> <span class="built_in">directory</span> where nvm should store different versions <span class="keyword">of</span> node.js.</span><br><span class="line">                                 If &lt;path&gt; is <span class="keyword">not</span> <span class="built_in">set</span>, <span class="keyword">the</span> current root will be displayed.</span><br><span class="line">  nvm <span class="built_in">version</span>                  : Displays <span class="keyword">the</span> current running <span class="built_in">version</span> <span class="keyword">of</span> nvm <span class="keyword">for</span> Windows. Aliased <span class="keyword">as</span> v.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="安装管理nodejs"><a href="#安装管理nodejs" class="headerlink" title="安装管理nodejs"></a>安装管理nodejs</h3><h4 id="查看本地安装的所有版本"><a href="#查看本地安装的所有版本" class="headerlink" title="查看本地安装的所有版本"></a>查看本地安装的所有版本</h4>nvm list 后显示的 * 表示的是当前正在使用的版本<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> nvm list</span><br><span class="line"></span><br><span class="line">  * <span class="number">15.3</span>.<span class="number">0</span> (Currently <span class="keyword">using</span> 64-bit executable)</span><br><span class="line">    <span class="number">10.4</span>.<span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="安装，版本号可自定义"><a href="#安装，版本号可自定义" class="headerlink" title="安装，版本号可自定义"></a>安装，版本号可自定义</h4><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nvm</span> install <span class="number">10</span>.<span class="number">4</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="使用特定版本"><a href="#使用特定版本" class="headerlink" title="使用特定版本"></a>使用特定版本</h4><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nvm</span> use <span class="number">10</span>.<span class="number">4</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nvm</span> uninstall <span class="number">11</span>.<span class="number">13</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Nvm</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>npm的镜像源以及代理的查看和配置</title>
    <url>/posts/b660c1ef.html</url>
    <content><![CDATA[<h3 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源"></a>镜像源</h3><h4 id="查询当前镜像源"><a href="#查询当前镜像源" class="headerlink" title="查询当前镜像源"></a>查询当前镜像源</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">npm <span class="built_in">get</span> registry</span><br></pre></td></tr></table></figure>
<h4 id="设置为淘宝镜像"><a href="#设置为淘宝镜像" class="headerlink" title="设置为淘宝镜像"></a>设置为淘宝镜像</h4><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">npm config <span class="keyword">set</span> <span class="keyword">registry</span> <span class="keyword">http</span>://<span class="keyword">registry</span>.npm.taobao.org/</span><br></pre></td></tr></table></figure>
<p>下载cnpm淘宝镜像</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https:<span class="regexp">//</span>registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<h4 id="设置默认的官方镜像"><a href="#设置默认的官方镜像" class="headerlink" title="设置默认的官方镜像"></a>设置默认的官方镜像</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">npm config set registry https:<span class="comment">//registry.npmjs.org/</span></span><br></pre></td></tr></table></figure>
<h4 id="查看和删除设置的淘宝镜像"><a href="#查看和删除设置的淘宝镜像" class="headerlink" title="查看和删除设置的淘宝镜像"></a>查看和删除设置的淘宝镜像</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">npm<span class="built_in"> config </span><span class="built_in">get</span> 前面设置的名字</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">npm config <span class="keyword">delete</span> 前面设置名字</span><br></pre></td></tr></table></figure>
<h3 id="npm代理"><a href="#npm代理" class="headerlink" title="npm代理"></a>npm代理</h3><h4 id="查看当前代理"><a href="#查看当前代理" class="headerlink" title="查看当前代理"></a>查看当前代理</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">npm<span class="built_in"> config </span><span class="built_in">get</span> proxy</span><br></pre></td></tr></table></figure>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">npm<span class="built_in"> config </span><span class="built_in">get</span> https-proxy</span><br></pre></td></tr></table></figure>
<h4 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">npm config set proxy http:<span class="comment">//server:port</span></span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">npm config set https-proxy http:<span class="comment">//server:port</span></span><br></pre></td></tr></table></figure>
<h4 id="删除代理"><a href="#删除代理" class="headerlink" title="删除代理"></a>删除代理</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">npm<span class="built_in"> config </span><span class="built_in">set</span><span class="built_in"> proxy </span><span class="literal">null</span></span><br></pre></td></tr></table></figure>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">npm<span class="built_in"> config </span><span class="built_in">set</span> https-proxy <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">npm config <span class="keyword">delete</span> proxy</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">npm config <span class="keyword">delete</span> https-proxy</span><br></pre></td></tr></table></figure>
<h3 id="git查看、设置、删除代理"><a href="#git查看、设置、删除代理" class="headerlink" title="git查看、设置、删除代理"></a>git查看、设置、删除代理</h3><h4 id="查看git代理"><a href="#查看git代理" class="headerlink" title="查看git代理"></a>查看git代理</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global --<span class="built_in">get</span> http.proxy</span><br><span class="line">git<span class="built_in"> config </span>--global --<span class="built_in">get</span> https.proxy</span><br></pre></td></tr></table></figure>

<h4 id="设置git代理"><a href="#设置git代理" class="headerlink" title="设置git代理"></a>设置git代理</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">git config <span class="attr">--global</span> http<span class="selector-class">.proxy</span> http:<span class="comment">//IP:Port</span></span><br><span class="line">git config <span class="attr">--global</span> https<span class="selector-class">.proxy</span> http:<span class="comment">//IP:Port</span></span><br></pre></td></tr></table></figure>
<h4 id="删除git代理"><a href="#删除git代理" class="headerlink" title="删除git代理"></a>删除git代理</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">git config <span class="attr">--global</span> <span class="attr">--unset</span> http<span class="selector-class">.proxy</span></span><br><span class="line">git config <span class="attr">--global</span> <span class="attr">--unset</span> https.proxy</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Npm</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo使用</title>
    <url>/posts/3b4634fc.html</url>
    <content><![CDATA[<p>本博客通过 <a href="'https://hexo.io/'">Hexo</a> + <a href="'http://theme-next.iissnan.com/'">Next主题</a> + <a href="'https://pages.github.com/'">Github pages</a> + <a href="'https://coding.net/'">Coding</a> 用了2天左右搭建而成，在此记录一下基本的使用命令，防止以后忘记</p>
<span id="more"></span>
<h3 id="新建草稿"><a href="#新建草稿" class="headerlink" title="新建草稿"></a>新建草稿</h3><p>新建的草稿文件会存放在<code>/source/_drafts</code>路径下</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="type">draft</span> &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Yu@DESKTOP-NNKS8QQ MINGW64 /f/blog (master)</span><br><span class="line">$ hexo new draft <span class="string">&quot;草稿文章测试&quot;</span></span><br><span class="line"><span class="built_in">INFO</span>  Validating<span class="built_in"> config</span></span><br><span class="line"><span class="built_in"></span><span class="built_in">INFO</span>  Created: F:\blog\source\_drafts\草稿文章测试.md</span><br></pre></td></tr></table></figure>
<h3 id="草稿运行预览"><a href="#草稿运行预览" class="headerlink" title="草稿运行预览"></a>草稿运行预览</h3><ul>
<li>如果你希望强行预览草稿，更改配置文件：<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">render_drafts:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li>也可以这种方式启动server：<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">server</span> <span class="comment">--drafts</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="草稿转正式文章"><a href="#草稿转正式文章" class="headerlink" title="草稿转正式文章"></a>草稿转正式文章</h4><p>当草稿写完成了要发布，输入如下命令将草稿转成正式文章，该命令会把<code>/source/_drafts</code>下的文章移到<code>/source/_posts</code>下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">hexo publish <span class="tag">&lt;<span class="name">filename</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="直接生成正式文章"><a href="#直接生成正式文章" class="headerlink" title="直接生成正式文章"></a>直接生成正式文章</h3><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;文章名字&quot;</span></span><br></pre></td></tr></table></figure>
<p>之后在<code>source/_posts</code>目录下面，多了一个<code>文章名字.md</code>的文件  </p>
<h3 id="设置多个标签"><a href="#设置多个标签" class="headerlink" title="设置多个标签"></a>设置多个标签</h3><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">tags:</span> [nrm,npm]</span><br></pre></td></tr></table></figure>
<h3 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h3><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo clean</span></span><br></pre></td></tr></table></figure>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><p>使用 Hexo 生成静态文件</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">generate</span></span><br></pre></td></tr></table></figure>
<p>简写：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo g</span></span><br></pre></td></tr></table></figure>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>Hexo 会监视文件变动并自动更新，您无须重启服务器</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">server</span></span><br></pre></td></tr></table></figure>
<p>简写：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo s</span></span><br></pre></td></tr></table></figure>
<h3 id="发布生产"><a href="#发布生产" class="headerlink" title="发布生产"></a>发布生产</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo deploy</span></span><br></pre></td></tr></table></figure>
<p>简写：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>nrm管理镜像源</title>
    <url>/posts/54eb2703.html</url>
    <content><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g nrm</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nrm <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<h4 id="查看可用的源："><a href="#查看可用的源：" class="headerlink" title="查看可用的源："></a>查看可用的源：</h4><p>带*的是当前使用的源</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">* npm -------- https:<span class="regexp">//</span>registry.npmjs.org/</span><br><span class="line">  yarn ------- https:<span class="regexp">//</span>registry.yarnpkg.com/</span><br><span class="line">  cnpm ------- http:<span class="regexp">//</span>r.cnpmjs.org/</span><br><span class="line">  taobao ----- https:<span class="regexp">//</span>registry.npm.taobao.org/</span><br><span class="line">  nj --------- https:<span class="regexp">//</span>registry.nodejitsu.com/</span><br><span class="line">  npmMirror -- https:<span class="regexp">//</span>skimdb.npmjs.com<span class="regexp">/registry/</span></span><br><span class="line">  edunpm ----- http:<span class="regexp">//</span>registry.enpmjs.org/</span><br></pre></td></tr></table></figure>
<h4 id="切换选择"><a href="#切换选择" class="headerlink" title="切换选择"></a>切换选择</h4><p>如果要切换到taobao源</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">nrm <span class="keyword">use</span> taobao</span><br></pre></td></tr></table></figure>
<h4 id="增加源"><a href="#增加源" class="headerlink" title="增加源"></a>增加源</h4><p>你可以增加定制的源，特别适用于添加企业内部的私有源，执行命令 nrm add &lt;registry&gt; &lt;url&gt;，其中reigstry为源名，url为源的路径。</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">nrm add <span class="keyword">registry</span> <span class="keyword">http</span>://<span class="keyword">registry</span>.npm.frp.trmap.cn/</span><br></pre></td></tr></table></figure>
<h4 id="删除源"><a href="#删除源" class="headerlink" title="删除源"></a>删除源</h4><p>&lt;registry&gt;是需要删除的对应的源名称</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">nrm del <span class="tag">&lt;<span class="name">registry</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="测试速度"><a href="#测试速度" class="headerlink" title="测试速度"></a>测试速度</h4><p>nrm test 测试相应源的响应时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nrm <span class="built_in">test</span> npm   </span><br></pre></td></tr></table></figure>
<p>nrm 查看所有的源的响应时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nrm <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">*</span> npm <span class="comment">---- 1189ms</span></span><br><span class="line">  yarn <span class="comment">--- 2893ms</span></span><br><span class="line">  cnpm <span class="comment">--- 715ms</span></span><br><span class="line">  taobao <span class="operator">-</span> <span class="number">413</span>ms</span><br><span class="line">  nj <span class="comment">----- Fetch Error</span></span><br><span class="line">  npmMirror  <span class="number">1393</span>ms</span><br><span class="line">  edunpm <span class="operator">-</span> <span class="keyword">Fetch</span> Error</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Npm</tag>
        <tag>Nrm</tag>
      </tags>
  </entry>
</search>
